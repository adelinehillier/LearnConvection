<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LearnConvection.jl ¬∑ LearnConvection</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LearnConvection</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>LearnConvection.jl</a><ul class="internal"><li><a class="tocitem" href="#Gaussian-Process-Regression"><span>Gaussian Process Regression</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>LearnConvection.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>LearnConvection.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adelinehillier/LearnConvection/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LearnConvection.jl"><a class="docs-heading-anchor" href="#LearnConvection.jl">LearnConvection.jl</a><a id="LearnConvection.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LearnConvection.jl" title="Permalink"></a></h1><ul></ul><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>data(filename::String, problem::Problem; D=16, N=4)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Simulation-data"><a class="docs-heading-anchor" href="#Simulation-data">Simulation data</a><a id="Simulation-data-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-data" title="Permalink"></a></h3><p><code>src/les</code> Large Eddy Simulations from <a href="https://github.com/CliMA/Oceananigans.jl">Oceananigans.jl</a></p><ul><li><p>Run Oceananigans LES simulations using <code>src/les/run.jl</code></p></li><li><p>Harvest data from the output files in <code>src/les/data</code> using <code>get_les_data.jl</code></p></li></ul><h3 id="Physics-based-parameterizations"><a class="docs-heading-anchor" href="#Physics-based-parameterizations">Physics-based parameterizations</a><a id="Physics-based-parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-based-parameterizations" title="Permalink"></a></h3><p><code>src/kpp</code> K-Profile Parameterizations from <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a></p><p><code>src/tke</code> Turbulent-Kinetic-Energy-based Parameterizations from <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a></p><h3 id="Machine-learning-based-parameterizations"><a class="docs-heading-anchor" href="#Machine-learning-based-parameterizations">Machine learning-based parameterizations</a><a id="Machine-learning-based-parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Machine-learning-based-parameterizations" title="Permalink"></a></h3><p><code>src/gpr</code> Gaussian Process Regression.</p><ul><li>Applying GPR to predict the evolution of horizontally averaged temperature or temperature flux profiles from LES simulations.</li></ul><hr/><h3 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h3><p>For each set of data that we plan to train, validate, or test on, all of the relevant information goes into a <code>ProfileData</code> object. This object is handles all pre- and post-processing of the data. The relevant information is as follows.</p><pre><code class="language-julia">filename = &quot;general_strat_32_profiles.jld2&quot;   # or filenames = [vector of filenames] to merge multiple simulations&#39; data
problem  = Sequential(&quot;T&quot;)                    # see Problems section below
D        = 32                                 # collapse profile data vector down to 16 gridpoints
N        = 4                                  # collect every 4 timesteps&#39; data for training</code></pre><p>The <code>ProfileData</code> object is constructed using the <code>data</code> function (or manually: see <code>src/data/Data.jl</code> where the ProfileData struct is defined).</p><pre><code class="language-julia">ùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)</code></pre><p>The <code>ProfileData</code> objects used for training, validation, and testing should be created independently.</p><h3 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h3><p>The problem specifies which mapping we are interested in, and therefore how the data should be pre- and post-processed for the model. All problem structs are implemented in <code>src/gpr/problems.jl</code> and the scaling functions in <code>src/gpr/scalings.jl</code>. The mappings corresponding to each problem are as follows.</p><table><tr><th style="text-align: left">Problem</th><th style="text-align: right">Predictor</th><th style="text-align: center"></th><th style="text-align: left">Target</th></tr><tr><td style="text-align: left"><code>Sequential(&quot;T&quot;)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i]$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;dT&quot;)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$(T[i]-T[i-1])/ \Delta{t&#39;} \approx \partial{t}(T)$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;wT&quot;)</code></td><td style="text-align: right"><span>$wT[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$wT[i]$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;KPP&quot;, KPP.Parameters())</code></td><td style="text-align: right"><span>$\text{KPP}(T[i])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i] - \text{KPP}(T[i])$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;TKE&quot;) TKEMassFlux.TKEParameters()</code></td><td style="text-align: right"><span>$\text{TKE}(T[i])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i] - \text{TKE}(T[i])$</span></td></tr></table><p>Where T[i] is a D-length vector of values from the horizontally-averaged temperature profile at time index t=i. <strong>Note that all temperature profiles are normalized using min-max scaling during pre-processing and un-normalized during post-processing.</strong> This scaling is computed based on the profile at the initial timestep.</p><p>We take the model output and predict the profile from it as follows.</p><table><tr><th style="text-align: left">Problem</th><th style="text-align: left">Prediction</th></tr><tr><td style="text-align: left"><code>Sequential(&quot;T&quot;)</code></td><td style="text-align: left"><span>$f(T[i-1]) = model(T[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;dT&quot;)</code></td><td style="text-align: left"><span>$f(T[i-1]) = model(T[i-1])\Delta{t} + T[i-1]$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;wT&quot;)</code></td><td style="text-align: left"><span>$f(wT[i-1]) = model(wT[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;KPP&quot;, KPP.Parameters())</code></td><td style="text-align: left"><span>$f(T[i]) = {model}({KPP}(T[i])) + {KPP}(T[i])$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;TKE&quot;) TKEMassFlux.TKEParameters()</code></td><td style="text-align: left"><span>$f(T[i]) = {model}({TKE}(T[i])) + {TKE}(T[i])$</span></td></tr></table><p>Where <span>$model(\mathbf{x})$</span> is the direct model output on predictor <span>$\mathbf{x}$</span>, which we hope will be close to the target.</p><p>See <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a> documentation for KPP and TKEMassFlux parameter options.</p><h3 id="Error"><a class="docs-heading-anchor" href="#Error">Error</a><a id="Error-1"></a><a class="docs-heading-anchor-permalink" href="#Error" title="Permalink"></a></h3><p>We have two functions for measuring error: <code>get_me_greedy_check</code>, which evaluates model fit on the training data, and <code>get_me_true_check</code>, which is our loss function as it tells us about model performance.</p><p><code>get_me_greedy_check</code> computes the mean error on the &quot;greedy&quot; check, which tells us how the model performs on the subset of the training data reserved for validation (according to <code>N</code>). It is the mean across all validation timesteps, <span>$X$</span>, of the euclidean distance between the direct model output, <span>${model} (\mathbf{x}_\mathbf{i})$</span>, and the target prediction, <span>$\mathbf{y}_\mathbf{target, i}$</span>, for each predictor, <span>$\mathbf{x}$</span>.</p><div>\[ME_{greedy} = \frac{1}{n_t}\ \sum_{i \in X}\lVert {model} (\mathbf{x}_\mathbf{i}) - \mathbf{y}_\mathbf{target, i} \rVert\]</div><p><code>get_me_true_check</code> computes the mean error on the &quot;true&quot; check. It is the mean across all timesteps (of which there are <span>$n_t$</span>) of the euclidean distance between the prediction (computed from the model output as in Prediction column of the table above) and the truth (which comes directly from the LES simulation with each vector having been averaged down to <code>D</code> gridpoints in the vertical).</p><p>The meaning of the prediction depends on the type of problem.</p><p>If the problem is a <code>Sequential</code> problem, the mean error is computed as follows.</p><div>\[ME_{true} = \frac{1}{n_t}\ \sum_{i=1}^{n_t-1} \lVert \hat{\mathbf{y_i}} - \mathbf{y_i} \rVert\]</div><div>\[\hat{\mathbf{y_i}} = f( \hat{\mathbf{y}}_\mathbf{i-1} )\]</div><div>\[\hat{\mathbf{y_0}} = \mathbf{x_0}\]</div><p>Each timestep&#39;s profile is predicted based on the previous model&#39;s timestep, with the initial condition at time index i=0 being the initial condition of the true simulation. The error thus evaluates how accurately the model evolves the profile forward from the initial profile <span>$\mathbf{x_0}$</span>‚Äìwhich is the only information the model is supplied with during testing.</p><p>If the problem is a <code>Residual</code> problem, the mean error is computed as follows.</p><div>\[ME_{true} = \frac{1}{n_t}\ \sum_{i=0}^{n_t-1} \lVert {f} (\mathbf{x_i}) - \mathbf{y_i} \rVert\]</div><p>The error evaluates how well the model predicts the true profile at a given time index based solely on the prediction from the <code>KPP</code> or <code>TKE</code> model at the same time index.</p><hr/><h2 id="Gaussian-Process-Regression"><a class="docs-heading-anchor" href="#Gaussian-Process-Regression">Gaussian Process Regression</a><a id="Gaussian-Process-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Process-Regression" title="Permalink"></a></h2><p>Gaussian Process (GP) regression produces a distribution over functions that interpolate the training data. Here we concern ourselves with the mean GP prediction.</p><h3 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h3><p>The kernel (or covariance) function sets the form of the interpolation function.</p><table><tr><th style="text-align: center">Kernel ID</th><th style="text-align: left">Name</th><th style="text-align: left">Parameters</th><th style="text-align: left">Equation</th></tr><tr><td style="text-align: center">1</td><td style="text-align: left">Squared exponential</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma e^{ - {\lVert x-x&#39; \rVert}^2 / 2 \gamma^2 }$</span></td></tr><tr><td style="text-align: center">2</td><td style="text-align: left">Mat√©rn with  ã=1/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma e^{ - \lVert x-x&#39;\rVert / \gamma }$</span></td></tr><tr><td style="text-align: center">3</td><td style="text-align: left">Mat√©rn with  ã=3/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma (1+c) e^{-\sqrt{3} \lVert x-x&#39;\rVert)/\gamma}$</span></td></tr><tr><td style="text-align: center">4</td><td style="text-align: left">Mat√©rn with  ã=5/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma ( 1 + \sqrt{5}\lVert x-x&#39;\rVert)/\gamma + 5{\lVert x-x&#39;\rVert}^2/(3\gamma^2) ) e^{{(-‚àö(5)*\lVert x-x&#39;\rVert}/\gamma}$</span></td></tr><tr><td style="text-align: center">5</td><td style="text-align: left">Rational quadratic</td><td style="text-align: left">Œ≥, œÉ, Œ±</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma (1+(x-x&#39;)&#39;(x-x&#39;)/(2*\alpha (\gamma^2))^{-\alpha}$</span></td></tr></table><p>Where Œ≥ is a length-scale parameter, œÉ is a signal variance parameter, and Œ± is an additional parameter used only in the rational quadratic kernel.</p><h3 id="Basic-Example"><a class="docs-heading-anchor" href="#Basic-Example">Basic Example</a><a id="Basic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Example" title="Permalink"></a></h3><p>In this example, we train our model and test our model on the data from the same simulation.</p><pre><code class="language-julia"># problems
params   = KPP.Parameters( )
problem  = Residual(&quot;KPP&quot;, params)

# data
filename = &quot;general_strat_32_profiles.jld2&quot;
D        = 16
N        = 4

# kernel
k        = 1
logŒ≥     = -3.0
logœÉ     = 0.0
distance = euclidean_distance
kernel   = get_kernel(k, logŒ≥, logœÉ, distance)

# data
ùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)

# model
ùí¢ = LearnConvection.GaussianProcess.model(ùíü; kernel = kernel)

# Animate the mean GP prediction.
anim = animate_profile(ùí¢, ùíü)
gif(anim, &quot;animated_profile.gif&quot;)
</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 7 September 2020 19:32">Monday 7 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
