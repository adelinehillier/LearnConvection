<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ LearnConvection</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LearnConvection</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Gaussian-Process-Regression"><span>Gaussian Process Regression</span></a></li></ul></li><li><a class="tocitem" href="main_function_index/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adelinehillier/LearnConvection/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LearnConvection.jl"><a class="docs-heading-anchor" href="#LearnConvection.jl">LearnConvection.jl</a><a id="LearnConvection.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LearnConvection.jl" title="Permalink"></a></h1><h3 id="Simulation-data"><a class="docs-heading-anchor" href="#Simulation-data">Simulation data</a><a id="Simulation-data-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-data" title="Permalink"></a></h3><p><code>src/les</code> Large Eddy Simulations from <a href="https://github.com/CliMA/Oceananigans.jl">Oceananigans.jl</a></p><ul><li><p>Run Oceananigans LES simulations using <code>src/les/run.jl</code></p></li><li><p>Harvest data from the output files in <code>src/les/data</code> using <code>get_les_data.jl</code></p></li></ul><h3 id="Physics-based-parameterizations"><a class="docs-heading-anchor" href="#Physics-based-parameterizations">Physics-based parameterizations</a><a id="Physics-based-parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-based-parameterizations" title="Permalink"></a></h3><p><code>src/kpp</code> K-Profile Parameterizations from <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a></p><p><code>src/tke</code> Turbulent-Kinetic-Energy-based Parameterizations from <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a></p><h3 id="Machine-learning-based-parameterizations"><a class="docs-heading-anchor" href="#Machine-learning-based-parameterizations">Machine learning-based parameterizations</a><a id="Machine-learning-based-parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Machine-learning-based-parameterizations" title="Permalink"></a></h3><p><code>src/gpr</code> Gaussian Process Regression.</p><ul><li>Applying GPR to predict the evolution of horizontally averaged temperature or temperature flux profiles from LES simulations.</li></ul><hr/><h3 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h3><p>For each set of data that we plan to train, validate, or test on, all of the relevant information goes into a <code>ProfileData</code> object. This object is handles all pre- and post-processing of the data. The relevant information is as follows.</p><pre><code class="language-julia">filename = &quot;general_strat_32_profiles.jld2&quot;   # or filenames = [vector of filenames] to merge multiple simulations&#39; data
problem  = Sequential(&quot;T&quot;)                    # see Problems section below
D        = 32                                 # collapse profile data vector down to 16 gridpoints
N        = 4                                  # collect every 4 timesteps&#39; data for training</code></pre><p>The <code>ProfileData</code> object is constructed using the <code>data</code> function (or manually: see <code>src/data/Data.jl</code> where the ProfileData struct is defined).</p><pre><code class="language-julia">ùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)</code></pre><p>The <code>ProfileData</code> objects used for training, validation, and testing should be created independently.</p><h3 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h3><p>The problem specifies which mapping we are interested in, and therefore how the data should be pre- and post-processed for the model. All problem structs are implemented in <code>src/gpr/problems.jl</code> and the scaling functions in <code>src/gpr/scalings.jl</code>. The mappings corresponding to each problem are as follows.</p><table><tr><th style="text-align: left">Problem</th><th style="text-align: right">Predictor</th><th style="text-align: center"></th><th style="text-align: left">Target</th></tr><tr><td style="text-align: left"><code>Sequential(&quot;T&quot;)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i]$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;dT&quot;)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$\frac{T[i]-T[i-1]}{\Delta{t&#39;}}$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;wT&quot;)</code></td><td style="text-align: right"><span>$wT[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$wT[i]$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;KPP&quot;,Œò)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$\frac{T[i] - \text{KPP}(i;T[i-1])}{\Delta{t}}$</span>   <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;TKE&quot;,Œò)</code></td><td style="text-align: right"><span>$T[i-1]$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$\frac{T[i] - \text{TKE}(i;T[i-1])}{\Delta{t}}$</span>   <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left"><code>Residual(&quot;KPP&quot;,Œò)</code></td><td style="text-align: right"><span>$\text{KPP}(i;T[i-1])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$\frac{T[i] - \text{KPP}(i;T[i-1])}{\Delta{t}}$</span> <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left"><code>Residual(&quot;TKE&quot;,Œò)</code></td><td style="text-align: right"><span>$\text{TKE}(i;T[i-1])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$\frac{T[i] - \text{TKE}(i;T[i-1])}{\Delta{t}}$</span> <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left"><code>Slack(&quot;KPP&quot;,Œò)</code></td><td style="text-align: right"><span>$\text{KPP}(i;T[0])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i] - \text{KPP}(i;T[0])$</span></td></tr><tr><td style="text-align: left"><code>Slack(&quot;TKE&quot;,Œò)</code></td><td style="text-align: right"><span>$\text{TKE}(i;T[0])$</span></td><td style="text-align: center"><span>$\xrightarrow{\text{model}}$</span></td><td style="text-align: left"><span>$T[i] - \text{TKE}(i;T[0])$</span></td></tr></table><p>Where T[i] is a D-length vector of values from the horizontally-averaged temperature profile at time index i, <span>$\Delta{t}$</span> is the time interval between steps, and Œò refers to the parameters for the KPP or TKE simulations (e.g. <code>KPP.Parameters()</code> or <code>TKEMassFlux.TKEParameters()</code> to use the default parameter values defined in <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a>).</p><p><span>$KPP(i;T[0])$</span> and <span>$TKE(i;T[0])$</span> are the KPP and TKE model predictions, respectively, for <span>$T[i]$</span> given initial condition <span>$T[0]$</span>, and <span>$KPP(i;T[i-1])$</span> and <span>$TKE(i;T[i-1])$</span> are the KPP and TKE model predictions, respectively, for <span>$T[i]$</span> given initial condition <span>$T[i-1]$</span>.</p><p><strong>Note that all temperature profiles are normalized using min-max scaling during pre-processing and un-normalized during post-processing.</strong> This scaling is computed based on the profile at the initial timestep.</p><p>We take the model output and predict the profile from it as follows.</p><table><tr><th style="text-align: left">Problem</th><th style="text-align: left">Prediction</th></tr><tr><td style="text-align: left"><code>Sequential(&quot;T&quot;)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = model(\mathbf{x})$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;dT&quot;)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = model(\mathbf{x})\Delta{t&#39;} + T[i-1]$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;wT&quot;)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = model(\mathbf{x})$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;KPP&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x})\Delta{t} + KPP(i;T[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Sequential(&quot;TKE&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x})\Delta{t} + TKE(i;T[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;KPP&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x})\Delta{t} + KPP(i;T[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Residual(&quot;TKE&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x})\Delta{t} + TKE(i;T[i-1])$</span></td></tr><tr><td style="text-align: left"><code>Slack(&quot;KPP&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x}) + KPP(i;T[0])$</span></td></tr><tr><td style="text-align: left"><code>Slack(&quot;TKE&quot;,Œò)</code></td><td style="text-align: left"><span>$f(\mathbf{x}) = {model}(\mathbf{x}) + TKE(i;T[0])$</span></td></tr></table><p>Where <span>$model(\mathbf{x})$</span> is the direct model output on predictor <span>$\mathbf{x}$</span>, which we hope will be close to the target.</p><p>See <a href="https://github.com/glwagner/OceanTurb.jl">OceanTurb.jl</a> documentation for KPP and TKEMassFlux parameter options.</p><h3 id="Error"><a class="docs-heading-anchor" href="#Error">Error</a><a id="Error-1"></a><a class="docs-heading-anchor-permalink" href="#Error" title="Permalink"></a></h3><p>We have two functions for measuring error: <code>get_me_greedy_check</code>, which evaluates model fit on the training data, and <code>get_me_true_check</code>, which is our loss function as it tells us about model performance.</p><p><code>get_me_greedy_check</code> computes the mean error on the &quot;greedy&quot; check, which tells us how the model performs on the subset of the training data reserved for validation (according to <code>N</code>). It is the mean across all validation timesteps, <span>$X$</span>, of the euclidean distance between the direct model output, <span>${model} (\mathbf{x}_\mathbf{i})$</span>, and the target prediction, <span>$\mathbf{y}_\mathbf{target, i}$</span>, for each predictor, <span>$\mathbf{x}$</span>.</p><div>\[ME_{greedy} = \frac{1}{n_t}\ \sum_{i \in X}\lVert {model} (\mathbf{x}_\mathbf{i}) - \mathbf{y}_\mathbf{target, i} \rVert\]</div><p><code>get_me_true_check</code> computes the mean error on the &quot;true&quot; check. It is the mean across all timesteps (of which there are <span>$n_t$</span>) of the euclidean distance between the prediction (computed from the model output as in Prediction column of the table above) and the truth (which comes directly from the LES simulation with each vector having been averaged down to <code>D</code> gridpoints in the vertical).</p><p>The meaning of the prediction depends on the type of problem.</p><p>If the problem is a <code>Sequential</code> or <code>Residual</code> problem, the mean error is computed as follows.</p><div>\[ME_{true} = \frac{1}{n_t}\ \sum_{i=1}^{n_t-1} \lVert \hat{\mathbf{y_i}} - \mathbf{y_i} \rVert\]</div><div>\[\hat{\mathbf{y_i}} = f( \hat{\mathbf{y}}_\mathbf{i-1} )\]</div><div>\[\hat{\mathbf{y_0}} = \mathbf{x_0}\]</div><p>Each timestep&#39;s profile is predicted based on the previous model&#39;s timestep, with the initial condition at time index i=0 being the initial condition of the true simulation. The error thus evaluates how accurately the model evolves the profile forward from the initial profile <span>$\mathbf{x_0}$</span>‚Äìwhich is the only information the model is supplied with during testing.</p><p>If the problem is a <code>Slack</code> problem, the mean error is computed as follows.</p><div>\[ME_{true} = \frac{1}{n_t}\ \sum_{i=0}^{n_t-1} \lVert {f} (\mathbf{x_i}) - \mathbf{y_i} \rVert\]</div><p>The error evaluates how well the model predicts the true profile at a given time index based solely on the prediction from the <code>KPP</code> or <code>TKE</code> model at the same time index.</p><hr/><h2 id="Gaussian-Process-Regression"><a class="docs-heading-anchor" href="#Gaussian-Process-Regression">Gaussian Process Regression</a><a id="Gaussian-Process-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Process-Regression" title="Permalink"></a></h2><p>Gaussian Process (GP) regression produces a distribution over functions that interpolate the training data. Here we concern ourselves with the mean GP prediction.</p><h3 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h3><p>The kernel (or covariance) function sets the form of the interpolation function.</p><table><tr><th style="text-align: center">Kernel ID</th><th style="text-align: left">Name</th><th style="text-align: left">Parameters</th><th style="text-align: left">Equation</th></tr><tr><td style="text-align: center">1</td><td style="text-align: left">Squared exponential</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma e^{ - {d(x,x&#39;)}^2 / 2 \gamma^2 }$</span></td></tr><tr><td style="text-align: center">2</td><td style="text-align: left">Mat√©rn with  ã=1/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma e^{ - d(x,x&#39;) / \gamma }$</span></td></tr><tr><td style="text-align: center">3</td><td style="text-align: left">Mat√©rn with  ã=3/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma (1+c) e^{-\sqrt{3} d(x,x&#39;))/\gamma}$</span></td></tr><tr><td style="text-align: center">4</td><td style="text-align: left">Mat√©rn with  ã=5/2</td><td style="text-align: left">Œ≥, œÉ</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma ( 1 + \frac{\sqrt{5}d(x,x&#39;)}{\gamma} + \frac{5{d(x,x&#39;)}^2}{3\gamma^2} ) e^{-‚àö(5) \frac{d(x,x&#39;)}{\gamma}}$</span></td></tr><tr><td style="text-align: center">5</td><td style="text-align: left">Rational quadratic</td><td style="text-align: left">Œ≥, œÉ, Œ±</td><td style="text-align: left"><span>$k(x,x&#39;) = \sigma (1+(x-x&#39;)&#39;(x-x&#39;)/(2*\alpha (\gamma^2))^{-\alpha}$</span></td></tr><tr><td style="text-align: center">6</td><td style="text-align: left">Spectral mixture product</td><td style="text-align: left"><span>$\mu, \sigma, w$</span></td><td style="text-align: left"><span>$\prod_{p=1}^{P} \sum_{a=1}^{A} w_{p,a}^2 \text{exp} ({-2\pi^2\tau_p^2 \sigma_{p,a}^2}) \cos{(2\pi\tau_p\mu_{p,a})}$</span>, <span>$\tau = x-x&#39;$</span> <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup></td></tr></table><p>Where Œ≥ is a length-scale parameter, œÉ is a signal variance parameter, Œ± is an additional parameter used only in the rational quadratic kernel, and <span>$d$</span> is the distance metric used in the kernel function. The options for <span>$d$</span> are <code>euclidean_distance</code>, <code>derivative_distance</code>, and <code>antiderivative_distance</code>.</p><h3 id="Basic-Example"><a class="docs-heading-anchor" href="#Basic-Example">Basic Example</a><a id="Basic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Example" title="Permalink"></a></h3><p>In this example, we train our model and test our model on the data from the same simulation.</p><pre><code class="language-julia"># problem
params   = KPP.Parameters()
problem  = Residual(&quot;KPP&quot;, params)

# data
train    = [&quot;general_strat_4_profiles.jld2&quot;, &quot;general_strat_16_profiles.jld2&quot;]
test     = &quot;general_strat_32_profiles.jld2&quot;
D        = 16
N        = 4

# kernel
k        = 1
logŒ≥     = 0.4
logœÉ     = 0.0
distance = euclidean_distance
kernel   = get_kernel(k, logŒ≥, logœÉ, distance)

# data
ùíü_train  = LearnConvection.Data.data(train, problem; D=D, N=N);
ùíü_test   = LearnConvection.Data.data(test, problem; D=D, N=N);

# ùí¢ is trained on ùíü_train
ùí¢ = LearnConvection.GaussianProcess.model(ùíü_train; kernel = kernel)

# animate the mean GP prediction, where ùí¢ is tested on ùíü_test
anim = animate_profile_and_model_output(ùí¢, ùíü_test)
gif(anim, &quot;basic_example.gif&quot;)</code></pre><p>This should output the following animation.</p><p><img src="figures/basic_example.gif" alt="Basic Example result"/></p><p>Where the plot on the left shows the mean GP prediction (blue dots) on the test data compared to the truth from the LES test simulation (orange line), and the plot on the right shows the direct model output (blue dots) compared to the target (orange line).</p><h3 id="Interactive-example"><a class="docs-heading-anchor" href="#Interactive-example">Interactive example</a><a id="Interactive-example-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-example" title="Permalink"></a></h3><p>Run <code>examples/gpr/interact.jl</code> for an interactive exploration of GPR that uses <a href="https://github.com/JuliaGizmos/Interact.jl">Interact.jl</a> and <a href="https://github.com/JuliaGizmos/Blink.jl">Blink.jl</a>.</p><p><img src="figures/interact_1.png" alt="Interact example 1"/></p><p><img src="figures/interact_2.png" alt="Interact example 2"/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><span>$\Delta{t&#39;}$</span> is a rescaled time interval equal to <span>$\Delta{t} / N^2$</span>, where <span>$N^2$</span> is the initial buoyancy stratification.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The <span>$T[i-1]$</span> given to the KPP or TKE model as an initial condition at each time index (i.e. the <span>$T[i-1]$</span> in <span>$KPP(i;T[i-1])$</span> and <span>$TKE(i;T[i-1])$</span>) is the LES prediction for <span>$T[i-1]$</span> during training, but the previous time step‚Äôs ‚Äúcorrected‚Äù prediction (<code>Prediction</code> in the second table) during testing.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>SMP: GPatt: Fast Multidimensional Pattern Extrapolation with GPs, arXiv 1310.5288, 2013, by Andrew Gordon Wilson, Elad Gilboa, Arye Nehorai and John P. Cunningham. Implemented in MATLAB <img src="https://github.com/alshedivat/gpml/blob/master/cov/covSM.m" alt="here"/>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="main_function_index/">Library ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 25 September 2020 03:58">Friday 25 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
