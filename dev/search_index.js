var documenterSearchIndex = {"docs":
[{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"CurrentModule = LearnConvection","category":"page"},{"location":"#LearnConvection.jl","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Modules = [LearnConvection]","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"data(filename::String, problem::Problem; D=16, N=4)","category":"page"},{"location":"#Simulation-data","page":"LearnConvection.jl","title":"Simulation data","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"src/les Large Eddy Simulations from Oceananigans.jl","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Run Oceananigans LES simulations using src/les/run.jl\nHarvest data from the output files in src/les/data using get_les_data.jl","category":"page"},{"location":"#Physics-based-parameterizations","page":"LearnConvection.jl","title":"Physics-based parameterizations","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"src/kpp K-Profile Parameterizations from OceanTurb.jl","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"src/tke Turbulent-Kinetic-Energy-based Parameterizations from OceanTurb.jl","category":"page"},{"location":"#Machine-learning-based-parameterizations","page":"LearnConvection.jl","title":"Machine learning-based parameterizations","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"src/gpr Gaussian Process Regression.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Applying GPR to predict the evolution of horizontally averaged temperature or temperature flux profiles from LES simulations.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"","category":"page"},{"location":"#Data","page":"LearnConvection.jl","title":"Data","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"For each set of data that we plan to train, validate, or test on, all of the relevant information goes into a ProfileData object. This object is handles all pre- and post-processing of the data. The relevant information is as follows.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"filename = \"general_strat_32_profiles.jld2\"   # or filenames = [vector of filenames] to merge multiple simulations' data\nproblem  = Sequential(\"T\")                    # see Problems section below\nD        = 32                                 # collapse profile data vector down to 16 gridpoints\nN        = 4                                  # collect every 4 timesteps' data for training","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The ProfileData object is constructed using the data function (or manually: see src/data/Data.jl where the ProfileData struct is defined).","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"ùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The ProfileData objects used for training, validation, and testing should be created independently.","category":"page"},{"location":"#Problems","page":"LearnConvection.jl","title":"Problems","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The problem specifies which mapping we are interested in, and therefore how the data should be pre- and post-processed for the model. All problem structs are implemented in src/gpr/problems.jl and the scaling functions in src/gpr/scalings.jl. The mappings corresponding to each problem are as follows.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Problem Predictor  Target\nSequential(\"T\") Ti-1 xrightarrowtextmodel Ti\nSequential(\"dT\") Ti-1 xrightarrowtextmodel (Ti-Ti-1) Deltat approx partialt(T)\nSequential(\"wT\") wTi-1 xrightarrowtextmodel wTi\nResidual(\"KPP\", KPP.Parameters()) textKPP(Ti) xrightarrowtextmodel Ti - textKPP(Ti)\nResidual(\"TKE\") TKEMassFlux.TKEParameters() textTKE(Ti) xrightarrowtextmodel Ti - textTKE(Ti)","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Where T[i] is a D-length vector of values from the horizontally-averaged temperature profile at time index t=i. Note that all temperature profiles are normalized using min-max scaling during pre-processing and un-normalized during post-processing. This scaling is computed based on the profile at the initial timestep.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"We take the model output and predict the profile from it as follows.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Problem Prediction\nSequential(\"T\") f(Ti-1) = model(Ti-1)\nSequential(\"dT\") f(Ti-1) = model(Ti-1)Deltat + Ti-1\nSequential(\"wT\") f(wTi-1) = model(wTi-1)\nResidual(\"KPP\", KPP.Parameters()) f(Ti) = model(KPP(Ti)) + KPP(Ti)\nResidual(\"TKE\") TKEMassFlux.TKEParameters() f(Ti) = model(TKE(Ti)) + TKE(Ti)","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Where model(mathbfx) is the direct model output on predictor mathbfx, which we hope will be close to the target.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"See OceanTurb.jl documentation for KPP and TKEMassFlux parameter options.","category":"page"},{"location":"#Error","page":"LearnConvection.jl","title":"Error","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"We have two functions for measuring error: get_me_greedy_check, which evaluates model fit on the training data, and get_me_true_check, which is our loss function as it tells us about model performance.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"get_me_greedy_check computes the mean error on the \"greedy\" check, which tells us how the model performs on the subset of the training data reserved for validation (according to N). It is the mean across all validation timesteps, X, of the euclidean distance between the direct model output, model (mathbfx_mathbfi), and the target prediction, mathbfy_mathbftarget i, for each predictor, mathbfx.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"ME_greedy = frac1n_t sum_i in XlVert model (mathbfx_mathbfi) - mathbfy_mathbftarget i rVert","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"get_me_true_check computes the mean error on the \"true\" check. It is the mean across all timesteps (of which there are n_t) of the euclidean distance between the prediction (computed from the model output as in Prediction column of the table above) and the truth (which comes directly from the LES simulation with each vector having been averaged down to D gridpoints in the vertical).","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The meaning of the prediction depends on the type of problem.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"If the problem is a Sequential problem, the mean error is computed as follows.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"ME_true = frac1n_t sum_i=1^n_t-1 lVert hatmathbfy_i - mathbfy_i rVert","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"hatmathbfy_i = f( hatmathbfy_mathbfi-1 )","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"hatmathbfy_0 = mathbfx_0","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Each timestep's profile is predicted based on the previous model's timestep, with the initial condition at time index i=0 being the initial condition of the true simulation. The error thus evaluates how accurately the model evolves the profile forward from the initial profile mathbfx_0‚Äìwhich is the only information the model is supplied with during testing.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"If the problem is a Residual problem, the mean error is computed as follows.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"ME_true = frac1n_t sum_i=0^n_t-1 lVert f (mathbfx_i) - mathbfy_i rVert","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The error evaluates how well the model predicts the true profile at a given time index based solely on the prediction from the KPP or TKE model at the same time index.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"","category":"page"},{"location":"#Gaussian-Process-Regression","page":"LearnConvection.jl","title":"Gaussian Process Regression","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Gaussian Process (GP) regression produces a distribution over functions that interpolate the training data. Here we concern ourselves with the mean GP prediction.","category":"page"},{"location":"#Kernels","page":"LearnConvection.jl","title":"Kernels","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"The kernel (or covariance) function sets the form of the interpolation function.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Kernel ID Name Parameters Equation\n1 Squared exponential Œ≥, œÉ k(xx) = sigma e^ - lVert x-x rVert^2  2 gamma^2 \n2 Mat√©rn with  ã=1/2 Œ≥, œÉ k(xx) = sigma e^ - lVert x-xrVert  gamma \n3 Mat√©rn with  ã=3/2 Œ≥, œÉ k(xx) = sigma (1+c) e^-sqrt3 lVert x-xrVert)gamma\n4 Mat√©rn with  ã=5/2 Œ≥, œÉ k(xx) = sigma ( 1 + fracsqrt5lVert x-xrVertgamma + 5lVert x-xrVert^2(3gamma^2) ) e^-(5)*lVert x-xrVertgamma\n5 Rational quadratic Œ≥, œÉ, Œ± k(xx) = sigma (1+(x-x)(x-x)(2*alpha (gamma^2))^-alpha","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"Where Œ≥ is a length-scale parameter, œÉ is a signal variance parameter, and Œ± is an additional parameter used only in the rational quadratic kernel.","category":"page"},{"location":"#Basic-Example","page":"LearnConvection.jl","title":"Basic Example","text":"","category":"section"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"In this example, we train our model and test our model on the data from the same simulation.","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"# problem\nparams   = KPP.Parameters()\nproblem  = Residual(\"KPP\", params)\n\n# data\ntrain    = [\"general_strat_4_profiles.jld2\", \"general_strat_16_profiles.jld2\"]\ntest     = \"general_strat_32_profiles.jld2\"\nD        = 16\nN        = 4\n\n# kernel\nk        = 1\nlogŒ≥     = 0.4\nlogœÉ     = 0.0\ndistance = euclidean_distance\nkernel   = get_kernel(k, logŒ≥, logœÉ, distance)\n\n# data\nùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)\n\n# model\nùí¢ = LearnConvection.GaussianProcess.model(ùíü; kernel = kernel)\n\n# data\nùíü_train     = LearnConvection.Data.data(train, problem; D=D, N=N);\nùíü_test      = LearnConvection.Data.data(test, problem; D=D, N=N);\n\n# ùí¢ is trained on ùíü_train\nùí¢ = LearnConvection.GaussianProcess.model(ùíü_train; kernel = kernel)\n\n# animate the mean prediction, where ùí¢ is tested on ùíü_test\nanim = animate_profile_and_model_output(ùí¢, ùíü_test)\ngif(anim, \"basic_example.gif\")","category":"page"},{"location":"","page":"LearnConvection.jl","title":"LearnConvection.jl","text":"(Image: Basic Example result)","category":"page"}]
}
