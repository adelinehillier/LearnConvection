var documenterSearchIndex = {"docs":
[{"location":"main_function_index/#Functions-in-LearnConvection-Module","page":"Library","title":"Functions in LearnConvection Module","text":"","category":"section"},{"location":"main_function_index/","page":"Library","title":"Library","text":"CurrentModule = LearnConvection","category":"page"},{"location":"main_function_index/","page":"Library","title":"Library","text":"","category":"page"},{"location":"main_function_index/#LearnConvection.Main","page":"Library","title":"LearnConvection.Main","text":"","category":"section"},{"location":"main_function_index/","page":"Library","title":"Library","text":"Modules = [LearnConvection.Main]","category":"page"},{"location":"main_function_index/#LearnConvection.Main.plot_profile-Tuple{Any,ProfileData,Any,Any}","page":"Library","title":"LearnConvection.Main.plot_profile","text":"plotprofile(gp::GP, data::ProfileData, Vname, timeindex, gprprediction)\n\nDescription\n\nUsed in interact.jl Plots the simulation profile at a single given index in the data timeseries along with the corresponding GP prediction (prediciting on the training data). i.e. produces a snapshot of the profile evolution. The gpr_prediction is computed outside this function for efficiency.\n\nArguments\n\n‚Ñ≥ (GP or NN). The model.\nùíü (ProfileData). The ProfileData object used for training and testing.\nV_name (ProfileData). The ProfileData object whose starting profile will be evolved forward using ‚Ñ≥.\ntime_index (Int). The time index\ngpr_prediction (Array). Output of getgprpred (which should only be computed once) on ‚Ñ≥ and ùíü.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Main.predict-Tuple{Any,ProfileData}","page":"Library","title":"LearnConvection.Main.predict","text":"Description\n\nPredict profile across all time steps for the true check.     - if the problem is sequential, predict profiles from start to finish without the training, using only the initial profile as the initial condition.     - if the problem is residual, predict profiles at each timestep using model-predicted difference between truth and physics-based model (KPP or TKE) prediction\n\nReturns an n-length array of D-length vectors, where n is the number of training points and D is the\n\nArguments\n\n‚Ñ≥ (GP or NN). The model you will use to approximate the mapping.\nùíü (ProfileData). The ProfileData object whose data ùí¢ will \"test on\", not necessarily the object that was used to train ùí¢.                     If the problem is sequential, ùíü is the ProfileData object whose starting profile will be evolved forward using ùí¢.\n\nKeyword Arguments\n\npostprocessed (bool or String). If false, return whatever the model predicts directly (direct model output)                                   If true, return the full predicted temperature profile calculated from the model output.                                   If \"both\", return both.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess","page":"Library","title":"LearnConvection.GaussianProcess","text":"","category":"section"},{"location":"main_function_index/","page":"Library","title":"Library","text":"Modules = [LearnConvection.GaussianProcess]","category":"page"},{"location":"main_function_index/#LearnConvection.GaussianProcess","page":"Library","title":"LearnConvection.GaussianProcess","text":"Includes all useful functions for applying GPR to T and wT profiles from Oceananigans.jl simulations. Uses ProfileData struct to store data and GP struct for performing GPR on the data in ProfileData object.\n\n\n\n\n\n","category":"module"},{"location":"main_function_index/#LearnConvection.GaussianProcess.GP","page":"Library","title":"LearnConvection.GaussianProcess.GP","text":"GP\n\nDescription\n\ndata structure for typical GPR computations\n\nData Structure and Description\n\nkernel::‚Ñ±, a Kernel object\nx_train::ùíÆ , an array of vectors (n-length array of D-length vectors)\nŒ±::ùíÆ2 , an array\nK::ùí∞ , matrix or sparse matrix\nCK::ùí±, cholesky factorization of K\n\n\n\n\n\n","category":"type"},{"location":"main_function_index/#LearnConvection.GaussianProcess.GP_multiple","page":"Library","title":"LearnConvection.GaussianProcess.GP_multiple","text":"GP_multiple\n\nDescription\n\ndata structure for GPR computations where each gridpoint in the prediction has a different predictor\n\nData Structure and Description\n\nGPs, Array of GP objects\nkernel, Kernel object\nx_train\n\n\n\n\n\n","category":"type"},{"location":"main_function_index/#LearnConvection.GaussianProcess.Kernel","page":"Library","title":"LearnConvection.GaussianProcess.Kernel","text":"Constructors for covariance (kernel) functions.\n\n  Constructor                   Description                                Isotropic/Anisotropic\n- SquaredExponentialI(Œ≥,œÉ):     squared exponential covariance function    isotropic\n- ExponentialI(Œ≥,œÉ):            exponential covariance function            isotropic\n- RationalQuadraticI(Œ≥,œÉ,Œ±):    rational quadratic covariance function     isotropic\n- Matern12I(Œ≥,œÉ):               Mat√©rn covariance function with  ã = 1/2.   isotropic\n- Matern32I(Œ≥,œÉ):               Mat√©rn covariance function with  ã = 3/2.   isotropic\n- Matern52I(Œ≥,œÉ):               Mat√©rn covariance function with  ã = 5/2.   isotropic\n- SMP(w,Œº,Œ≥):                   Spectral mixture product cov. function\n\nDistance metrics\n\n- euclidean_distance            l¬≤-norm:  d(x,x') = || x - x' ||\",\n- derivative_distance           H¬π-norm:  d(x,x') = || diff(x)./diff(z) - diff(x')./diff(z) ||\",\n- antiderivative_distance       H‚Åª¬π-norm: d(x,x') = || diff(x).*diff(z) - diff(x').*diff(z) ||\"\n\n\n\n\n\n","category":"type"},{"location":"main_function_index/#LearnConvection.GaussianProcess.SquaredExponentialI","page":"Library","title":"LearnConvection.GaussianProcess.SquaredExponentialI","text":"SquaredExponentialI(Œ≥,œÉ): squared exponential covariance function, isotropic \n\n\n\n\n\n","category":"type"},{"location":"main_function_index/#LearnConvection.GaussianProcess.antiderivative_distance-Tuple{Any,Any,Any}","page":"Library","title":"LearnConvection.GaussianProcess.antiderivative_distance","text":"antiderivative_distance: computes the H‚Åª¬π-norm w.r.t z of two vectors\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.compute_kernel_matrix-Tuple{Any,Any}","page":"Library","title":"LearnConvection.GaussianProcess.compute_kernel_matrix","text":"computekernelmatrix(kernel, x)\n\nDescription\n\nComputes the kernel matrix for GPR\n\nArguments\n\nk : (Kernel) kernel function k(a,b).\nx : (array of predictors). x[1] is a vector\n\nReturn\n\nsK: (symmetric matrix). A symmetric matrix with entries sK[i,j] = k(x[i], x[j]). This is only meaningful if k(x,y) = k(y,x) (it should)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.derivative_distance-Tuple{Any,Any,Any}","page":"Library","title":"LearnConvection.GaussianProcess.derivative_distance","text":"derivative_distance: computes the H¬π-norm w.r.t z of two vectors\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.euclidean_distance-Tuple{Any,Any,Any}","page":"Library","title":"LearnConvection.GaussianProcess.euclidean_distance","text":"euclidean_distance: computes the Euclidean distance (l¬≤-norm) between two vectors\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.mean_log_marginal_loss-Tuple{Any,LearnConvection.GaussianProcess.GP}","page":"Library","title":"LearnConvection.GaussianProcess.mean_log_marginal_loss","text":"meanlogmarginalloss(ytrain, ùí¢::GP; add_constant=false)\n\nDescription\n\nComputes log marginal loss for each element in the output and averages the results. Assumes noise-free observations.\n\nlog(p(y|X)) = -(1/2) * (y'Œ± + 2sum(Diagonal(CK)) + nlog(2pi)) where n is the number of training points and\n\nArguments\n\ny_train: (Array). training outputs (prediction), must have the same number as x_train\nùí¢: (GP).\n\nKeyword Arguments\n\nadd_constant: (bool). whether to give the exact value of the loss or leave out an added constant for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.model-NTuple{4,Any}","page":"Library","title":"LearnConvection.GaussianProcess.model","text":"model(xtrain, ytrain; kernel; sparsitythreshold = 0.0, robust = true, entrythreshold = sqrt(eps(1.0)))\n\nDescription\n\nConstructs the posterior distribution for a gp. In other words this does the 'training' automagically.\n\nArguments\n\nx_train: (array). training inputs (predictors), must be an array of states.                     length-n array of D-length vectors, where D is the length of each input n is the number of training points.\ny_train: (array). training outputs (prediction), must have the same number as x_train                     length-n array of D-length vectors.\nkernel: (Kernel). Kernel object. See kernels.jl.                     kernel_function(kernel)(x,x') maps predictor x predictor to real numbers.\n\nKeyword Arguments\n\nz: (vector). values w.r.t. which to derivate the state (default none).\nnormalize: (bool). whether to normalize the data during preprocessing and reverse the scaling for postprocessing. Can lead to better performance.\nhyperparameters: (array). default = []. hyperparameters that enter into the kernel\nsparsity_threshold: (number). default = 0.0. a number between 0 and 1 that determines when to use sparse array format. The default is to never use it\nrobust: (bool). default = true. This decides whether to uniformly scale the diagonal entries of the Kernel Matrix. This sometimes helps with Cholesky factorizations.\nentry_threshold: (number). default = sqrt(eps(1.0)). This decides whether an entry is \"significant\" or not. For typical machines this number will be about 10^(-8) * largest entry of kernel matrix.\n\nReturn\n\nGP object\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.model-Tuple{ProfileData}","page":"Library","title":"LearnConvection.GaussianProcess.model","text":"model(ùíü::ProfileData; kernel::Kernel = Kernel(), stencil_size=nothing)\n\nDescription\n\nCreate an instance of GP using data from ProfileData object ùíü.\n\nArguments\n\nùíü::ProfileData, Data for training the GP\n\nKeyword Arguments\n\nkernel::Kernel,\nstencil_size::Int64\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP_multiple}","page":"Library","title":"LearnConvection.GaussianProcess.model_output","text":"prediction(x, ùí¢::GP_multiple)\n\nDescription\n\nGiven state x, GP_multiple ùí¢, returns the mean GP prediction\n\nArguments\n\nx: single scaled state\nùí¢: GP_multiple object with which to make the prediction\n\nReturn\n\ny: scaled prediction\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.GaussianProcess.uncertainty-Tuple{Any,LearnConvection.GaussianProcess.GP}","page":"Library","title":"LearnConvection.GaussianProcess.uncertainty","text":"uncertainty(x, ùí¢::GP)\n\nDescription\n\nGiven state x and GP ùí¢, output the variance at a point\n\nArguments\n\nx: state\n\nReturn\n\nvar: variance\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data","page":"Library","title":"LearnConvection.Data","text":"","category":"section"},{"location":"main_function_index/","page":"Library","title":"Library","text":"Modules = [LearnConvection.Data]","category":"page"},{"location":"main_function_index/#LearnConvection.Data.ProfileData","page":"Library","title":"LearnConvection.Data.ProfileData","text":"ProfileData\n\nDescription\n\ndata structure for preparing profile data for analysis with gpr or nn.\n\nData Structure and Description\n\nv::Array,           Nz x Nt array of T or wT values directly from the LES simulation, not preprocessed.\nvavg::Array,        Nt-length array of Nz-length vectors from LES simulation, scaled and pre-processed\nx::Array,           all simulation inputs, scaled and pre-processed\ny::Array,           all simulation inputs, scaled and pre-processed\nx_train::Array,     training inputs (predictors; array of states). (length-n array of D-length vectors, where D is the length of each input n is the number of training points)\ny_train::Array,     training outputs (predictions) (length-n array of D-length vectors).\nvalidation_set::Array, vector of indices corresponding to validation data\nz::Array,           Nz-length vector of depth values\nzavg::Array,        length-D vector; depth values averaged to D gridpoints\nt::Array,           timeseries [seconds]\nNt::Int64,          length(timeseries)\nstate_variables\nproblem::Problem,   what mapping you wish to evaluate with the model. (Sequential(\"T\"), Sequential(\"wT\"), Residual(\"T\"), Residual(\"KPP\"), or Residual(\"TKE\"))\n\n\n\n\n\n","category":"type"},{"location":"main_function_index/#LearnConvection.Data.ReadJLD2_LESbraryData-Tuple{Any}","page":"Library","title":"LearnConvection.Data.ReadJLD2_LESbraryData","text":"LESbraryData(filename)\n\nDescription\n\nConstructor for Oceananigans data type. Loads data from LES\n\nFields for the output are\n\n# initial conditions\nT‚Å∞::ùíÆ\nS‚Å∞::ùíÆ\nU‚Å∞::ùíÆ\nV‚Å∞::ùíÆ\n# fields at each moment in time\nT::ùíØ\nS::ùíØ\nU::ùíØ\nV::ùíØ\n# some second order statistics at each moment in time\nwT::ùíØ\nwS::ùíØ\nuu::ùíØ\nvv::ùíØ\nww::ùíØ\ntke::ùíØ\n# simulation constants\nœÅ::ùí∞\nŒ±::ùí∞\nŒ≤::ùí∞\nc·µñ::ùí∞\nf‚Å∞::ùí∞\ng::ùí∞\n# time and grid\nt::ùíÆ\nz::ùíÆ\n# #top boundary condition data, see string for type of boundary condition\n# top_T::ùí∞\n# top_S::ùí∞\n# top_U::ùí∞\n# top_V::ùí∞\n# #bottom boundary condition data, see string for type of boundary condtion\n# bottom_T::ùí∞\n# bottom_S::ùí∞\n# bottom_U::ùí∞\n# bottom_V::ùí∞\n#info about the simulation\ninfo::ùí±\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.ReadJLD2_OceananigansData-Tuple{Any}","page":"Library","title":"LearnConvection.Data.ReadJLD2_OceananigansData","text":"OceananigansData(filename)\n\nDescription\n\nConstructor for Oceananigans data type. Loads data from LES\n\nFields for the output are\n\n# initial conditions\nT‚Å∞::ùíÆ\nS‚Å∞::ùíÆ\nU‚Å∞::ùíÆ\nV‚Å∞::ùíÆ\n# fields at each moment in time\nT::ùíØ\nS::ùíØ\nU::ùíØ\nV::ùíØ\n# some second order statistics at each moment in time\nwT::ùíØ\nwS::ùíØ\nuu::ùíØ\nvv::ùíØ\nww::ùíØ\ntke::ùíØ\n# simulation constants\nœÅ::ùí∞\nŒ±::ùí∞\nŒ≤::ùí∞\nc·µñ::ùí∞\nf‚Å∞::ùí∞\ng::ùí∞\n# time and grid\nt::ùíÆ\nz::ùíÆ\n#top boundary condition data, see string for type of boundary condition\ntop_T::ùí∞\ntop_S::ùí∞\ntop_U::ùí∞\ntop_V::ùí∞\n#bottom boundary condition data, see string for type of boundary condtion\nbottom_T::ùí∞\nbottom_S::ùí∞\nbottom_U::ùí∞\nbottom_V::ùí∞\n#info about the simulation\ninfo::ùí±\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.ReadNetCDF_OceananigansData-Tuple{Any}","page":"Library","title":"LearnConvection.Data.ReadNetCDF_OceananigansData","text":"OceananigansData(filename)\n\nDescription\n\nConstructor for Oceananigans data type. Loads data from LES\n\nFields for the output are\n\n# initial conditions\nT‚Å∞::ùíÆ\nS‚Å∞::ùíÆ\nU‚Å∞::ùíÆ\nV‚Å∞::ùíÆ\n# fields at each moment in time\nT::ùíØ\nS::ùíØ\nU::ùíØ\nV::ùíØ\n# some second order statistics at each moment in time\nwT::ùíØ\nwS::ùíØ\nuu::ùíØ\nvv::ùíØ\nww::ùíØ\n# simulation constants\nœÅ::ùí∞\nŒ±::ùí∞\nŒ≤::ùí∞\nc·µñ::ùí∞\nf‚Å∞::ùí∞\ng::ùí∞\n# time and grid\nt::ùíÆ\nz::ùíÆ\n#top boundary condition data, see string for type of boundary condition\ntop_T::ùí∞\ntop_S::ùí∞\ntop_U::ùí∞\ntop_V::ùí∞\n#bottom boundary condition data, see string for type of boundary condtion\nbottom_T::ùí∞\nbottom_S::ùí∞\nbottom_U::ùí∞\nbottom_V::ùí∞\n#info about the simulation\ninfo::ùí±\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.closure_free_convection_flexible-Tuple{Any,Any,LearnConvection.Data.OceananigansData}","page":"Library","title":"LearnConvection.Data.closure_free_convection_flexible","text":"closurefreeconvection_flexible(N, Œît, les::OceananigansData; subsample = 1, grid = 1)\n\nDescription\n\nconstructs forward map. Assumes initial conditions and boundary conditions are taken from les data. Adds two more parameters compared to previous one\n\nArguments\n\nN: number of gridpoints to output to\nŒît: time step size in seconds\nles: les data of the OceananigansData type\n\nKeyword Arguments\n\nsubsample: indices to subsample in time,\ngrid: in case one wants to save the model grid\npower: a method of modifying the scaling law, default is 1\n\nOutput\n\nThe forward map. A function that takes parameters and outputs temperature profiles\nùë™: parameters in KPP, assumes that \nùë™[1]: Surface Layer Fraction  \nùë™[2]: Nonlocal Flux Amplitude \nùë™[3]: Diffusivity Amplitude \nùë™[4]: Shear Constant, w1 * w2 \nùë™[5] = Shear Constant 2   ùë™[6]: Shear Constant 3,\nThe extra parameters correspond to  C[5] * w1^(1-power) * w2^(1+power)\nwhere w1 = max(0, h * Qb)^(1/3), w2 = sqrt(ùë™[6] * h^2), are two velocity scales.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.closure_free_convection_kpp_full_evolution-Tuple{Any,Any,Any,LearnConvection.Data.OceananigansData}","page":"Library","title":"LearnConvection.Data.closure_free_convection_kpp_full_evolution","text":"closurefreeconvection(N, Œît, les::OceananigansData; subsample = 1, grid = 1)\n\nDescription\n\nconstructs forward map. Assumes initial conditions and boundary conditions are taken from les data.\n\nArguments\n\nN: number of gridpoints to output to\nŒît: time step size in seconds\nles: les data of the OceananigansData type\n\nKeyword Arguments\n\nsubsample: indices to subsample in time,\ngrid: in case one wants to save the model grid\n\nOutput\n\nThe forward map. A function that takes parameters and outputs temperature profiles\nùë™: parameters in KPP, assumes that \nùë™[1]: Surface Layer Fraction  \nùë™[2]: Nonlocal Flux Amplitude \nùë™[3]: Diffusivity Amplitude \nùë™[4]: Shear Constant \n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.custom_avg-Tuple{Any,Any}","page":"Library","title":"LearnConvection.Data.custom_avg","text":"From sandreza/Learning/sandbox/oceananigansconverter.jl   https://github.com/sandreza/Learning/blob/master/sandbox/oceananigansconverter.jl\n\ncustom_avg(Œ¶, n)\n\nDescription\n\nAverage a field down to n.\nRequires field to have evenly spaced points. Size of N leq length(Œ¶).\nFurthermore requires\n\nArguments\n\nŒ¶ :(vector) The field, an array\nn :(Int) number of grid points to average down to.\n\nReturn\n\nŒ¶2 :(vector) The field with values averaged, an array\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.data-Tuple{Array{String,1},LearnConvection.Data.Problem}","page":"Library","title":"LearnConvection.Data.data","text":"data(filename, D; N=4)\n\nDescription\n\nReturns an instance of ProfileData containing training data from multiple simulations. *** Important:     ONLY v, xtrain and ytrain contain data from all filenames;     the remaining attributes are taken from the first filename in filenames\n\nArguments\n\nfilenames: (string)  Vector of filenames (.nc or .jld2) to collect data from.\nproblem: (Problem). What mapping you wish to evaluate with the model. (Sequential(\"T\"), Sequential(\"wT\"), Residual(\"T\"), Residual(\"KPP\"), or Residual(\"TKE\"))\n\nKeyword Arguments\n\nD: (integer)        Number of gridpoints in the z direction to average the data to for training and prediction.\nN: (integer)        Interval between the timesteps to be reserved for training data (default 4).                       If N=4, the profile data for every 4 timesteps will be reserved for training (~25% training data);                       the rest will be used in the validation set.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.data-Tuple{String,LearnConvection.Data.Problem}","page":"Library","title":"LearnConvection.Data.data","text":"data(filename, problem; D=16, N=4)\n\nDescription\n\nReturns a ProfileData object based on data from filename\n\nArguments\n\nfilename: (string)  Name of the NetCDF or JLD2 file containing the data from the Oceananigans simulation.\nproblem: (Problem). What mapping you wish to evaluate with the model.\n\nKeyword Arguments\n\nD: (integer)        Number of gridpoints in the z direction to average the data to for training and prediction.\nN: (integer)        Interval between the timesteps to be reserved for training data (default 4).                       If N=4, the profile data for every 4 timesteps will be reserved for training (~25% training data);                       the rest will be used in the validation set.\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_T}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"get_predictors_targets(vavg::Array, problem::Sequential_T)\n\nDescription\n\nReturns x and y, the predictors and target predictions from which to extract the training and verification data for \"T\" profiles.\n\nmodel( predictors ) -> targets\n      model( T[i] ) -> T[i+1]\n\nArguments\n\nvavg: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (SequentialT)     SequentialT object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_wT}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"get_predictors_targets(vavg, problem::Sequential_wT)\n\nDescription\n\nReturns x and y, the predictors and targets from which to extract the training and verification data for \"wT\" profiles.\n\n model( predictor ) -> target\n     model( wT[i] ) -> wT[i+1]\n\nArguments\n\nvavg: (Array)                  Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (SequentialwT)       SequentialwT object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Array,LearnConvection.Data.Sequential_dT}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"get_predictors_targets(vavg::Array, problem::Sequential_T)\n\nDescription\n\nReturns x and y, the scaled predictor and target pairs from which to extract the training and verification data sets for \"T\" profiles.\n\nmodel( predictor ) -> target\n     model( T[i] ) -> (T[i+1]-T[i])/Œît ‚âà ‚àÇt(T)\n\nArguments\n\nvavg: (Array)                Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (SequentialdT)     SequentialT object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"getpredictorstargets(vavg::Array, problem::Residual_KPP)\n\nDescription\n\nReturns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.\nScales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.\n\nmodel( predictors ) = targets\nmodel( KPP(T[i])  ) = T[i] - KPP(T[i])\n\nArguments\n\nvavg: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (ResidualKPP)    ResidualKPP object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"getpredictorstargets(vavg::Array, problem::Residual_KPP)\n\nDescription\n\nReturns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.\nScales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.\n\nmodel( predictors ) = targets\nmodel( KPP(T[i])  ) = T[i] - KPP(T[i])\n\nArguments\n\nvavg: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (ResidualKPP)    ResidualKPP object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}","page":"Library","title":"LearnConvection.Data.get_predictors_targets","text":"getpredictorstargets(vavg::Array, problem::Slack_KPP)\n\nDescription\n\nReturns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.\nScales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.\n\nmodel( predictors ) = targets\nmodel( KPP(T[i])  ) = T[i] - KPP(T[i])\n\nArguments\n\nvavg: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.\nproblem: (SlackKPP)    SlackKPP object associated with the data (output of get_problem)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_problem-NTuple{6,Any}","page":"Library","title":"LearnConvection.Data.get_problem","text":"get_problem(problem::Problem, data::OceananigansData, timeseries)\n\nDescription\n\nCreates an instance of a Problem struct depending on the type of mapping.\nReturns the problem and the correct data array from the OceananigansData objectssociated with the variable of interest.\n\nArguments\n\n'problem': (Problem).      what mapping you wish to evaluate with the model. (Sequential(\"T\"), Sequential(\"wT\"))\n'v': (Array).              Array of values\n'les': (OceananigansData). LES simulation output\n'N¬≤': (Number)             initial buoyancy stratification\n'D': (Number)              number of grid points in the vertical\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.get_v-Tuple{Any,Any}","page":"Library","title":"LearnConvection.Data.get_v","text":"get_v(problem)\n\nDescription\n\nReturn data array from the OceananigansData object associated with the variable of interest.\n\nArguments\n\n'problem': (Problem).     what mapping you wish to evaluate with the model. (Sequential(\"T\"), Sequential(\"wT\"))\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_T}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"postprocess_prediction(predictor, prediction, problem::Sequential_T)\n\nDescription\n\nTakes in a scaled predictor, T[i], the scaled GP prediction on the predictor, G(T[i]), and a Sequential_T object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by\n\n       prediction = model( predictor )\n predicted T[i+1] = model( T[i] )\n\nArguments\n\npredictor: (Array)            T[i], the scaled predictor for a temperature profile\nprediction: (Array)           model(T[i), the scaled prediction for a temperature profile\nproblem: (Sequential_T)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_dT}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"postprocess_prediction(predictor, model_output, problem::Sequential_dT)\n\nDescription\n\nTakes in a scaled predictor, T[i], the scaled model output on the predictor, model(T[i]), and a Sequential_T object. Returns the unscaled prediction (predicted temperature profile), T[i+1], computed from T[i] and model(T[i]) by\n\npredicted T[i+1] = model(T[i])Œît + T[i]\n\nArguments\n\npredictor: (Array)            T[i], the scaled predictor for a temperature profile\nmodel_output: (Array)         model(T[i]), the scaled model output for a temperature profile\nproblem: (Sequential_dT)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_wT}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"postprocess_prediction(predictor, prediction, problem::Sequential_wT)\n\nDescription\n\nTakes in a scaled predictor, wT[i], the scaled model prediction on the predictor, model(wT[i]), and a Sequential_wT object. Returns the temperature profile, T[i+1], computed from model(T[i]) by\n\n       prediction = model(predictor)\npredicted wT[i+1] = model(wT[i])\n\nArguments\n\npredictor: (Array)                wT[i], the predictor for a wT profile\nprediction: (Array)               predicted wT[i+1], the model prediction for a wT profile\nproblem: (SequentialwT)          SequentialwT object associated with the data\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"Description\n\nTakes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Residual_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by\n\n       prediction = model(predictor) # residual\n predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])\n\nArguments\n\npredictor: (Array)            T[i], the predictor for a temperature profile\nprediction: (Array)           model(T[i), the prediction for a temperature profile\nproblem: (Residual_KPP)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"Description\n\nTakes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Residual_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by\n\n       prediction = model(predictor) # residual\n predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])\n\nArguments\n\npredictor: (Array)            T[i], the predictor for a temperature profile\nprediction: (Array)           model(T[i), the prediction for a temperature profile\nproblem: (Residual_KPP)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}","page":"Library","title":"LearnConvection.Data.postprocess_prediction","text":"Description\n\nTakes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Slack_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by\n\n       prediction = model(predictor) # residual\n predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])\n\nArguments\n\npredictor: (Array)            T[i], the predictor for a temperature profile\nprediction: (Array)           model(T[i), the prediction for a temperature profile\nproblem: (Slack_KPP)\n\n\n\n\n\n","category":"method"},{"location":"main_function_index/#LearnConvection.Data.read_les_output-Tuple{String}","page":"Library","title":"LearnConvection.Data.read_les_output","text":"readlesoutput(filename::String; days=0)\n\n\n\n\n\n","category":"method"},{"location":"#LearnConvection.jl","page":"Home","title":"LearnConvection.jl","text":"","category":"section"},{"location":"#Simulation-data","page":"Home","title":"Simulation data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"src/les Large Eddy Simulations from Oceananigans.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run Oceananigans LES simulations using src/les/run.jl\nHarvest data from the output files in src/les/data using get_les_data.jl","category":"page"},{"location":"#Physics-based-parameterizations","page":"Home","title":"Physics-based parameterizations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"src/kpp K-Profile Parameterizations from OceanTurb.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"src/tke Turbulent-Kinetic-Energy-based Parameterizations from OceanTurb.jl","category":"page"},{"location":"#Machine-learning-based-parameterizations","page":"Home","title":"Machine learning-based parameterizations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"src/gpr Gaussian Process Regression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Applying GPR to predict the evolution of horizontally averaged temperature or temperature flux profiles from LES simulations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Data","page":"Home","title":"Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For each set of data that we plan to train, validate, or test on, all of the relevant information goes into a ProfileData object. This object is handles all pre- and post-processing of the data. The relevant information is as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"filename = \"general_strat_32_profiles.jld2\"   # or filenames = [vector of filenames] to merge multiple simulations' data\nproblem  = Sequential(\"T\")                    # see Problems section below\nD        = 32                                 # collapse profile data vector down to 16 gridpoints\nN        = 4                                  # collect every 4 timesteps' data for training","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ProfileData object is constructed using the data function (or manually: see src/data/Data.jl where the ProfileData struct is defined).","category":"page"},{"location":"","page":"Home","title":"Home","text":"ùíü = LearnConvection.Data.data(filename, problem; D=D, N=N)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ProfileData objects used for training, validation, and testing should be created independently.","category":"page"},{"location":"#Problems","page":"Home","title":"Problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The problem specifies which mapping we are interested in, and therefore how the data should be pre- and post-processed for the model. All problem structs are implemented in src/gpr/problems.jl and the scaling functions in src/gpr/scalings.jl. The mappings corresponding to each problem are as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem Predictor  Target\nSequential(\"T\") Ti-1 xrightarrowtextmodel Ti\nSequential(\"dT\") Ti-1 xrightarrowtextmodel fracTi-Ti-1Deltat [1]\nSequential(\"wT\") wTi-1 xrightarrowtextmodel wTi\nSequential(\"KPP\",Œò) Ti-1 xrightarrowtextmodel fracTi - textKPP(iTi-1)Deltat   [2]\nSequential(\"TKE\",Œò) Ti-1 xrightarrowtextmodel fracTi - textTKE(iTi-1)Deltat   [2]\nResidual(\"KPP\",Œò) textKPP(iTi-1) xrightarrowtextmodel fracTi - textKPP(iTi-1)Deltat [2]\nResidual(\"TKE\",Œò) textTKE(iTi-1) xrightarrowtextmodel fracTi - textTKE(iTi-1)Deltat [2]\nSlack(\"KPP\",Œò) textKPP(iT0) xrightarrowtextmodel Ti - textKPP(iT0)\nSlack(\"TKE\",Œò) textTKE(iT0) xrightarrowtextmodel Ti - textTKE(iT0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where T[i] is a D-length vector of values from the horizontally-averaged temperature profile at time index i, Deltat is the time interval between steps, and Œò refers to the parameters for the KPP or TKE simulations (e.g. KPP.Parameters() or TKEMassFlux.TKEParameters() to use the default parameter values defined in OceanTurb.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"KPP(iT0) and TKE(iT0) are the KPP and TKE model predictions, respectively, for Ti given initial condition T0, and KPP(iTi-1) and TKE(iTi-1) are the KPP and TKE model predictions, respectively, for Ti given initial condition Ti-1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that all temperature profiles are normalized using min-max scaling during pre-processing and un-normalized during post-processing. This scaling is computed based on the profile at the initial timestep.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Deltat is a rescaled time interval equal to Deltat  N^2, where N^2 is the initial buoyancy stratification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: The Ti-1 given to the KPP or TKE model as an initial condition at each time index (i.e. the Ti-1 in KPP(iTi-1) and TKE(iTi-1)) is the LES prediction for Ti-1 during training, but the previous time step‚Äôs ‚Äúcorrected‚Äù prediction (Prediction in the second table) during testing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We take the model output and predict the profile from it as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem Prediction\nSequential(\"T\") f(mathbfx) = model(mathbfx)\nSequential(\"dT\") f(mathbfx) = model(mathbfx)Deltat + Ti-1\nSequential(\"wT\") f(mathbfx) = model(mathbfx)\nSequential(\"KPP\",Œò) f(mathbfx) = model(mathbfx)Deltat + KPP(iTi-1)\nSequential(\"TKE\",Œò) f(mathbfx) = model(mathbfx)Deltat + TKE(iTi-1)\nResidual(\"KPP\",Œò) f(mathbfx) = model(mathbfx)Deltat + KPP(iTi-1)\nResidual(\"TKE\",Œò) f(mathbfx) = model(mathbfx)Deltat + TKE(iTi-1)\nSlack(\"KPP\",Œò) f(mathbfx) = model(mathbfx) + KPP(iT0)\nSlack(\"TKE\",Œò) f(mathbfx) = model(mathbfx) + TKE(iT0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where model(mathbfx) is the direct model output on predictor mathbfx, which we hope will be close to the target.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See OceanTurb.jl documentation for KPP and TKEMassFlux parameter options.","category":"page"},{"location":"#Error","page":"Home","title":"Error","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have two functions for measuring error: get_me_greedy_check, which evaluates model fit on the training data, and get_me_true_check, which is our loss function as it tells us about model performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_me_greedy_check computes the mean error on the \"greedy\" check, which tells us how the model performs on the subset of the training data reserved for validation (according to N). It is the mean across all validation timesteps, X, of the euclidean distance between the direct model output, model (mathbfx_mathbfi), and the target prediction, mathbfy_mathbftarget i, for each predictor, mathbfx.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME_greedy = frac1n_t sum_i in XlVert model (mathbfx_mathbfi) - mathbfy_mathbftarget i rVert","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_me_true_check computes the mean error on the \"true\" check. It is the mean across all timesteps (of which there are n_t) of the euclidean distance between the prediction (computed from the model output as in Prediction column of the table above) and the truth (which comes directly from the LES simulation with each vector having been averaged down to D gridpoints in the vertical).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The meaning of the prediction depends on the type of problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the problem is a Sequential or Residual problem, the mean error is computed as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME_true = frac1n_t sum_i=1^n_t-1 lVert hatmathbfy_i - mathbfy_i rVert","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmathbfy_i = f( hatmathbfy_mathbfi-1 )","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmathbfy_0 = mathbfx_0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each timestep's profile is predicted based on the previous model's timestep, with the initial condition at time index i=0 being the initial condition of the true simulation. The error thus evaluates how accurately the model evolves the profile forward from the initial profile mathbfx_0‚Äìwhich is the only information the model is supplied with during testing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the problem is a Slack problem, the mean error is computed as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME_true = frac1n_t sum_i=0^n_t-1 lVert f (mathbfx_i) - mathbfy_i rVert","category":"page"},{"location":"","page":"Home","title":"Home","text":"The error evaluates how well the model predicts the true profile at a given time index based solely on the prediction from the KPP or TKE model at the same time index.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Gaussian-Process-Regression","page":"Home","title":"Gaussian Process Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gaussian Process (GP) regression produces a distribution over functions that interpolate the training data. Here we concern ourselves with the mean GP prediction.","category":"page"},{"location":"#Kernels","page":"Home","title":"Kernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The kernel (or covariance) function sets the form of the interpolation function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kernel ID Name Parameters Equation\n1 Squared exponential Œ≥, œÉ k(xx) = sigma e^ - d(xx)^2  2 gamma^2 \n2 Mat√©rn with  ã=1/2 Œ≥, œÉ k(xx) = sigma e^ - d(xx)  gamma \n3 Mat√©rn with  ã=3/2 Œ≥, œÉ k(xx) = sigma (1+c) e^-sqrt3 d(xx))gamma\n4 Mat√©rn with  ã=5/2 Œ≥, œÉ k(xx) = sigma ( 1 + fracsqrt5d(xx)gamma + frac5d(xx)^23gamma^2 ) e^-(5) fracd(xx)gamma\n5 Rational quadratic Œ≥, œÉ, Œ± k(xx) = sigma (1+(x-x)(x-x)(2*alpha (gamma^2))^-alpha\n6 Spectral mixture product mu sigma w prod_p=1^P sum_a=1^A w_pa^2 textexp (-2pi^2tau_p^2 sigma_pa^2) cos(2pitau_pmu_pa), tau = x-x [3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where Œ≥ is a length-scale parameter, œÉ is a signal variance parameter, Œ± is an additional parameter used only in the rational quadratic kernel, and d is the distance metric used in the kernel function. The options for d are euclidean_distance, derivative_distance, and antiderivative_distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: SMP: GPatt: Fast Multidimensional Pattern Extrapolation with GPs, arXiv 1310.5288, 2013, by Andrew Gordon Wilson, Elad Gilboa, Arye Nehorai and John P. Cunningham. Implemented in MATLAB (Image: here).","category":"page"},{"location":"#Basic-Example","page":"Home","title":"Basic Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example, we train our model and test our model on the data from the same simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# problem\nparams   = KPP.Parameters()\nproblem  = Residual(\"KPP\", params)\n\n# data\ntrain    = [\"general_strat_4_profiles.jld2\", \"general_strat_16_profiles.jld2\"]\ntest     = \"general_strat_32_profiles.jld2\"\nD        = 16\nN        = 4\n\n# kernel\nk        = 1\nlogŒ≥     = 0.4\nlogœÉ     = 0.0\ndistance = euclidean_distance\nkernel   = get_kernel(k, logŒ≥, logœÉ, distance)\n\n# data\nùíü_train  = LearnConvection.Data.data(train, problem; D=D, N=N);\nùíü_test   = LearnConvection.Data.data(test, problem; D=D, N=N);\n\n# ùí¢ is trained on ùíü_train\nùí¢ = LearnConvection.GaussianProcess.model(ùíü_train; kernel = kernel)\n\n# animate the mean GP prediction, where ùí¢ is tested on ùíü_test\nanim = animate_profile_and_model_output(ùí¢, ùíü_test)\ngif(anim, \"basic_example.gif\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This should output the following animation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Basic Example result)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where the plot on the left shows the mean GP prediction (blue dots) on the test data compared to the truth from the LES test simulation (orange line), and the plot on the right shows the direct model output (blue dots) compared to the target (orange line).","category":"page"},{"location":"#Interactive-example","page":"Home","title":"Interactive example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run examples/gpr/interact.jl for an interactive exploration of GPR that uses Interact.jl and Blink.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Interact example 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Interact example 2)","category":"page"}]
}
