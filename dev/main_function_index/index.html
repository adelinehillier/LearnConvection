<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Â· LearnConvection</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LearnConvection</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#LearnConvection.Main"><span>LearnConvection.Main</span></a></li><li class="toplevel"><a class="tocitem" href="#LearnConvection.GaussianProcess"><span>LearnConvection.GaussianProcess</span></a></li><li class="toplevel"><a class="tocitem" href="#LearnConvection.Data"><span>LearnConvection.Data</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adelinehillier/LearnConvection/blob/master/docs/src/main_function_index.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-in-LearnConvection-Module"><a class="docs-heading-anchor" href="#Functions-in-LearnConvection-Module">Functions in LearnConvection Module</a><a id="Functions-in-LearnConvection-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-in-LearnConvection-Module" title="Permalink"></a></h1><ul><li><a href="#LearnConvection.GaussianProcess"><code>LearnConvection.GaussianProcess</code></a></li><li><a href="#LearnConvection.Data.ProfileData"><code>LearnConvection.Data.ProfileData</code></a></li><li><a href="#LearnConvection.GaussianProcess.GP"><code>LearnConvection.GaussianProcess.GP</code></a></li><li><a href="#LearnConvection.GaussianProcess.GP_multiple"><code>LearnConvection.GaussianProcess.GP_multiple</code></a></li><li><a href="#LearnConvection.GaussianProcess.Kernel"><code>LearnConvection.GaussianProcess.Kernel</code></a></li><li><a href="#LearnConvection.GaussianProcess.SquaredExponentialI"><code>LearnConvection.GaussianProcess.SquaredExponentialI</code></a></li><li><a href="#LearnConvection.Data.ReadJLD2_OceananigansData-Tuple{Any}"><code>LearnConvection.Data.ReadJLD2_OceananigansData</code></a></li><li><a href="#LearnConvection.Data.ReadNetCDF_OceananigansData-Tuple{Any}"><code>LearnConvection.Data.ReadNetCDF_OceananigansData</code></a></li><li><a href="#LearnConvection.Data.closure_free_convection_flexible-Tuple{Any,Any,LearnConvection.Data.OceananigansData}"><code>LearnConvection.Data.closure_free_convection_flexible</code></a></li><li><a href="#LearnConvection.Data.closure_free_convection_kpp_full_evolution-Tuple{Any,Any,LearnConvection.Data.OceananigansData}"><code>LearnConvection.Data.closure_free_convection_kpp_full_evolution</code></a></li><li><a href="#LearnConvection.Data.custom_avg-Tuple{Any,Any}"><code>LearnConvection.Data.custom_avg</code></a></li><li><a href="#LearnConvection.Data.data-Tuple{String,LearnConvection.Data.Problem}"><code>LearnConvection.Data.data</code></a></li><li><a href="#LearnConvection.Data.data-Tuple{Array{String,1},LearnConvection.Data.Problem}"><code>LearnConvection.Data.data</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_T}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,LearnConvection.Data.Sequential_dT}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_wT}"><code>LearnConvection.Data.get_predictors_targets</code></a></li><li><a href="#LearnConvection.Data.get_problem-NTuple{6,Any}"><code>LearnConvection.Data.get_problem</code></a></li><li><a href="#LearnConvection.Data.get_v-Tuple{Any,Any}"><code>LearnConvection.Data.get_v</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_dT}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_T}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_wT}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a></li><li><a href="#LearnConvection.GaussianProcess.antiderivative_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.antiderivative_distance</code></a></li><li><a href="#LearnConvection.GaussianProcess.compute_kernel_matrix-Tuple{Any,Any}"><code>LearnConvection.GaussianProcess.compute_kernel_matrix</code></a></li><li><a href="#LearnConvection.GaussianProcess.derivative_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.derivative_distance</code></a></li><li><a href="#LearnConvection.GaussianProcess.euclidean_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.euclidean_distance</code></a></li><li><a href="#LearnConvection.GaussianProcess.mean_log_marginal_loss-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.mean_log_marginal_loss</code></a></li><li><a href="#LearnConvection.GaussianProcess.model-Tuple{ProfileData}"><code>LearnConvection.GaussianProcess.model</code></a></li><li><a href="#LearnConvection.GaussianProcess.model-NTuple{4,Any}"><code>LearnConvection.GaussianProcess.model</code></a></li><li><a href="#LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP_multiple}"><code>LearnConvection.GaussianProcess.model_output</code></a></li><li><a href="#LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.model_output</code></a></li><li><a href="#LearnConvection.GaussianProcess.uncertainty-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.uncertainty</code></a></li><li><a href="#LearnConvection.Main.plot_profile-Tuple{Any,ProfileData,Any,Any}"><code>LearnConvection.Main.plot_profile</code></a></li><li><a href="#LearnConvection.Main.predict-Tuple{Any,ProfileData}"><code>LearnConvection.Main.predict</code></a></li></ul><h1 id="LearnConvection.Main"><a class="docs-heading-anchor" href="#LearnConvection.Main">LearnConvection.Main</a><a id="LearnConvection.Main-1"></a><a class="docs-heading-anchor-permalink" href="#LearnConvection.Main" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Main.plot_profile-Tuple{Any,ProfileData,Any,Any}" href="#LearnConvection.Main.plot_profile-Tuple{Any,ProfileData,Any,Any}"><code>LearnConvection.Main.plot_profile</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>plot<em>profile(gp::GP, data::ProfileData, V</em>name, time<em>index, gpr</em>prediction)</p><p><strong>Description</strong></p><p>Used in interact.jl Plots the simulation profile at a single given index in the data timeseries along with the corresponding GP prediction (prediciting on the training data). i.e. produces a snapshot of the profile evolution. The gpr_prediction is computed outside this function for efficiency.</p><p><strong>Arguments</strong></p><ul><li><code>â„³</code> (GP or NN). The model.</li><li><code>ğ’Ÿ</code> (ProfileData). The ProfileData object used for training and testing.</li><li><code>V_name</code> (ProfileData). The ProfileData object whose starting profile will be evolved forward using â„³.</li><li><code>time_index</code> (Int). The time index</li><li><code>gpr_prediction</code> (Array). Output of get<em>gpr</em>pred (which should only be computed once) on â„³ and ğ’Ÿ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/main/plot_profile.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Main.predict-Tuple{Any,ProfileData}" href="#LearnConvection.Main.predict-Tuple{Any,ProfileData}"><code>LearnConvection.Main.predict</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Description</strong></p><p>Predict profile across all time steps for the true check.     - if the problem is sequential, predict profiles from start to finish without the training, using only the initial profile as the initial condition.     - if the problem is residual, predict profiles at each timestep using model-predicted difference between truth and physics-based model (KPP or TKE) prediction</p><p>Returns an n-length array of D-length vectors, where n is the number of training points and D is the</p><p><strong>Arguments</strong></p><ul><li><code>â„³</code> (GP or NN). The model you will use to approximate the mapping.</li><li><code>ğ’Ÿ</code> (ProfileData). The ProfileData object whose data ğ’¢ will &quot;test on&quot;, not necessarily the object that was used to train ğ’¢.                     If the problem is sequential, ğ’Ÿ is the ProfileData object whose starting profile will be evolved forward using ğ’¢.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>postprocessed</code> (bool or String). If false, return whatever the model predicts directly (direct model output)                                   If true, return the full predicted temperature profile calculated from the model output.                                   If &quot;both&quot;, return both.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/main/predict.jl#L2-L17">source</a></section></article><h1 id="LearnConvection.GaussianProcess"><a class="docs-heading-anchor" href="#LearnConvection.GaussianProcess">LearnConvection.GaussianProcess</a><a id="LearnConvection.GaussianProcess-1"></a><a class="docs-heading-anchor-permalink" href="#LearnConvection.GaussianProcess" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess" href="#LearnConvection.GaussianProcess"><code>LearnConvection.GaussianProcess</code></a> â€” <span class="docstring-category">Module</span></header><section><div><p>Includes all useful functions for applying GPR to T and wT profiles from Oceananigans.jl simulations. Uses ProfileData struct to store data and GP struct for performing GPR on the data in ProfileData object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/GaussianProcess.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.GP" href="#LearnConvection.GaussianProcess.GP"><code>LearnConvection.GaussianProcess.GP</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>GP</p><p><strong>Description</strong></p><ul><li>data structure for typical GPR computations</li></ul><p><strong>Data Structure and Description</strong></p><pre><code class="language-none">kernel::â„±, a Kernel object
x_train::ğ’® , an array of vectors (n-length array of D-length vectors)
Î±::ğ’®2 , an array
K::ğ’° , matrix or sparse matrix
CK::ğ’±, cholesky factorization of K</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.GP_multiple" href="#LearnConvection.GaussianProcess.GP_multiple"><code>LearnConvection.GaussianProcess.GP_multiple</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>GP_multiple</p><p><strong>Description</strong></p><ul><li>data structure for GPR computations where each gridpoint in the prediction has a different predictor</li></ul><p><strong>Data Structure and Description</strong></p><pre><code class="language-none">GPs, Array of GP objects
kernel, Kernel object
x_train</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.Kernel" href="#LearnConvection.GaussianProcess.Kernel"><code>LearnConvection.GaussianProcess.Kernel</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>Constructors for covariance (kernel) functions.</p><pre><code class="language-none">  Constructor                   Description                                Isotropic/Anisotropic
- SquaredExponentialI(Î³,Ïƒ):     squared exponential covariance function    isotropic
- ExponentialI(Î³,Ïƒ):            exponential covariance function            isotropic
- RationalQuadraticI(Î³,Ïƒ,Î±):    rational quadratic covariance function     isotropic
- Matern12I(Î³,Ïƒ):               MatÃ©rn covariance function with Ê‹ = 1/2.   isotropic
- Matern32I(Î³,Ïƒ):               MatÃ©rn covariance function with Ê‹ = 3/2.   isotropic
- Matern52I(Î³,Ïƒ):               MatÃ©rn covariance function with Ê‹ = 5/2.   isotropic
- SMP(w,Î¼,Î³):                   Spectral mixture product cov. function</code></pre><p>Distance metrics</p><pre><code class="language-none">- euclidean_distance            lÂ²-norm:  d(x,x&#39;) = || x - x&#39; ||&quot;,
- derivative_distance           HÂ¹-norm:  d(x,x&#39;) = || diff(x)./diff(z) - diff(x&#39;)./diff(z) ||&quot;,
- antiderivative_distance       Hâ»Â¹-norm: d(x,x&#39;) = || diff(x).*diff(z) - diff(x&#39;).*diff(z) ||&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/kernels.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.SquaredExponentialI" href="#LearnConvection.GaussianProcess.SquaredExponentialI"><code>LearnConvection.GaussianProcess.SquaredExponentialI</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>SquaredExponentialI(Î³,Ïƒ): squared exponential covariance function, isotropic </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/kernels.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.antiderivative_distance-Tuple{Any,Any,Any}" href="#LearnConvection.GaussianProcess.antiderivative_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.antiderivative_distance</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>antiderivative_distance: computes the Hâ»Â¹-norm w.r.t z of two vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/distances.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.compute_kernel_matrix-Tuple{Any,Any}" href="#LearnConvection.GaussianProcess.compute_kernel_matrix-Tuple{Any,Any}"><code>LearnConvection.GaussianProcess.compute_kernel_matrix</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>compute<em>kernel</em>matrix(kernel, x)</p><p><strong>Description</strong></p><ul><li>Computes the kernel matrix for GPR</li></ul><p><strong>Arguments</strong></p><ul><li><code>k</code> : (Kernel) kernel function k(a,b).</li><li><code>x</code> : (array of predictors). x[1] is a vector</li></ul><p><strong>Return</strong></p><ul><li><code>sK</code>: (symmetric matrix). A symmetric matrix with entries sK[i,j] = k(x[i], x[j]). This is only meaningful if k(x,y) = k(y,x) (it should)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L186-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.derivative_distance-Tuple{Any,Any,Any}" href="#LearnConvection.GaussianProcess.derivative_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.derivative_distance</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>derivative_distance: computes the HÂ¹-norm w.r.t z of two vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/distances.jl#L61-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.euclidean_distance-Tuple{Any,Any,Any}" href="#LearnConvection.GaussianProcess.euclidean_distance-Tuple{Any,Any,Any}"><code>LearnConvection.GaussianProcess.euclidean_distance</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>euclidean_distance: computes the Euclidean distance (lÂ²-norm) between two vectors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/distances.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.mean_log_marginal_loss-Tuple{Any,LearnConvection.GaussianProcess.GP}" href="#LearnConvection.GaussianProcess.mean_log_marginal_loss-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.mean_log_marginal_loss</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>mean<em>log</em>marginal<em>loss(y</em>train, ğ’¢::GP; add_constant=false)</p><p><strong>Description</strong></p><p>Computes log marginal loss for each element in the output and averages the results. Assumes noise-free observations.</p><p>log(p(y|X)) = -(1/2) * (y&#39;<em>Î± + 2</em>sum(Diagonal(CK)) + n<em>log(2</em>pi)) where n is the number of training points and</p><p><strong>Arguments</strong></p><ul><li><code>y_train</code>: (Array). training outputs (prediction), must have the same number as x_train</li><li><code>ğ’¢</code>: (GP).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>add_constant</code>: (bool). whether to give the exact value of the loss or leave out an added constant for efficiency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.model-NTuple{4,Any}" href="#LearnConvection.GaussianProcess.model-NTuple{4,Any}"><code>LearnConvection.GaussianProcess.model</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>model(x<em>train, y</em>train; kernel; sparsity<em>threshold = 0.0, robust = true, entry</em>threshold = sqrt(eps(1.0)))</p><p><strong>Description</strong></p><p>Constructs the posterior distribution for a gp. In other words this does the &#39;training&#39; automagically.</p><p><strong>Arguments</strong></p><ul><li><code>x_train</code>: (array). training inputs (predictors), must be an array of states.                     length-n array of D-length vectors, where D is the length of each input n is the number of training points.</li><li><code>y_train</code>: (array). training outputs (prediction), must have the same number as x_train                     length-n array of D-length vectors.</li><li><code>kernel</code>: (Kernel). Kernel object. See kernels.jl.                     kernel_function(kernel)(x,x&#39;) maps predictor x predictor to real numbers.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>z</code>: (vector). values w.r.t. which to derivate the state (default none).</li><li><code>normalize</code>: (bool). whether to normalize the data during preprocessing and reverse the scaling for postprocessing. Can lead to better performance.</li><li><code>hyperparameters</code>: (array). default = []. hyperparameters that enter into the kernel</li><li><code>sparsity_threshold</code>: (number). default = 0.0. a number between 0 and 1 that determines when to use sparse array format. The default is to never use it</li><li><code>robust</code>: (bool). default = true. This decides whether to uniformly scale the diagonal entries of the Kernel Matrix. This sometimes helps with Cholesky factorizations.</li><li><code>entry_threshold</code>: (number). default = sqrt(eps(1.0)). This decides whether an entry is &quot;significant&quot; or not. For typical machines this number will be about 10^(-8) * largest entry of kernel matrix.</li></ul><p><strong>Return</strong></p><ul><li>GP object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.model-Tuple{ProfileData}" href="#LearnConvection.GaussianProcess.model-Tuple{ProfileData}"><code>LearnConvection.GaussianProcess.model</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>model(ğ’Ÿ::ProfileData; kernel::Kernel = Kernel(), stencil_size=nothing)</p><p><strong>Description</strong></p><p>Create an instance of GP using data from ProfileData object ğ’Ÿ.</p><p><strong>Arguments</strong></p><ul><li>ğ’Ÿ::ProfileData, Data for training the GP</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>kernel::Kernel,</li><li>stencil_size::Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP_multiple}" href="#LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP_multiple}"><code>LearnConvection.GaussianProcess.model_output</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>prediction(x, ğ’¢::GP_multiple)</p><p><strong>Description</strong></p><ul><li>Given state x, GP_multiple ğ’¢, returns the mean GP prediction</li></ul><p><strong>Arguments</strong></p><ul><li><code>x</code>: single scaled state</li><li><code>ğ’¢</code>: GP_multiple object with which to make the prediction</li></ul><p><strong>Return</strong></p><ul><li><code>y</code>: scaled prediction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP}" href="#LearnConvection.GaussianProcess.model_output-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.model_output</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>prediction(x, ğ’¢::GP)</p><p><strong>Description</strong></p><ul><li>Given state x, GP ğ’¢, returns the mean GP prediction</li></ul><p><strong>Arguments</strong></p><ul><li><code>x</code>: single scaled state</li><li><code>ğ’¢</code>: GP object with which to make the prediction</li></ul><p><strong>Return</strong></p><ul><li><code>y</code>: scaled prediction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L136-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.GaussianProcess.uncertainty-Tuple{Any,LearnConvection.GaussianProcess.GP}" href="#LearnConvection.GaussianProcess.uncertainty-Tuple{Any,LearnConvection.GaussianProcess.GP}"><code>LearnConvection.GaussianProcess.uncertainty</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>uncertainty(x, ğ’¢::GP)</p><p><strong>Description</strong></p><ul><li>Given state x and GP ğ’¢, output the variance at a point</li></ul><p><strong>Arguments</strong></p><ul><li><code>x</code>: state</li></ul><p><strong>Return</strong></p><ul><li><code>var</code>: variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/gpr/gp.jl#L166-L174">source</a></section></article><h1 id="LearnConvection.Data"><a class="docs-heading-anchor" href="#LearnConvection.Data">LearnConvection.Data</a><a id="LearnConvection.Data-1"></a><a class="docs-heading-anchor-permalink" href="#LearnConvection.Data" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.ProfileData" href="#LearnConvection.Data.ProfileData"><code>LearnConvection.Data.ProfileData</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>ProfileData</p><p><strong>Description</strong></p><ul><li>data structure for preparing profile data for analysis with gpr or nn.</li></ul><p><strong>Data Structure and Description</strong></p><pre><code class="language-none">v::Array,           Nz x Nt array of T or wT values directly from the LES simulation, not preprocessed.
vavg::Array,        Nt-length array of Nz-length vectors from LES simulation, scaled and pre-processed
x::Array,           all simulation inputs, scaled and pre-processed
y::Array,           all simulation inputs, scaled and pre-processed
x_train::Array,     training inputs (predictors; array of states). (length-n array of D-length vectors, where D is the length of each input n is the number of training points)
y_train::Array,     training outputs (predictions) (length-n array of D-length vectors).
validation_set::Array, vector of indices corresponding to validation data
z::Array,           Nz-length vector of depth values
zavg::Array,        length-D vector; depth values averaged to D gridpoints
t::Array,           timeseries [seconds]
Nt::Int64,          length(timeseries)
state_variables
problem::Problem,   what mapping you wish to evaluate with the model. (Sequential(&quot;T&quot;), Sequential(&quot;wT&quot;), Residual(&quot;T&quot;), Residual(&quot;KPP&quot;), or Residual(&quot;TKE&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/Data.jl#L80-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.ReadJLD2_OceananigansData-Tuple{Any}" href="#LearnConvection.Data.ReadJLD2_OceananigansData-Tuple{Any}"><code>LearnConvection.Data.ReadJLD2_OceananigansData</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>OceananigansData(filename)</p><p><strong>Description</strong></p><ul><li>Constructor for Oceananigans data type. Loads data from LES</li></ul><p><strong>Fields for the output are</strong></p><pre><code class="language-none"># initial conditions
Tâ°::ğ’®
Sâ°::ğ’®
Uâ°::ğ’®
Vâ°::ğ’®
# fields at each moment in time
T::ğ’¯
S::ğ’¯
U::ğ’¯
V::ğ’¯
# some second order statistics at each moment in time
wT::ğ’¯
wS::ğ’¯
uu::ğ’¯
vv::ğ’¯
ww::ğ’¯
tke::ğ’¯
# simulation constants
Ï::ğ’°
Î±::ğ’°
Î²::ğ’°
cáµ–::ğ’°
fâ°::ğ’°
g::ğ’°
# time and grid
t::ğ’®
z::ğ’®
#top boundary condition data, see string for type of boundary condition
top_T::ğ’°
top_S::ğ’°
top_U::ğ’°
top_V::ğ’°
#bottom boundary condition data, see string for type of boundary condtion
bottom_T::ğ’°
bottom_S::ğ’°
bottom_U::ğ’°
bottom_V::ğ’°
#info about the simulation
info::ğ’±</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/les/output_to_data.jl#L63-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.ReadNetCDF_OceananigansData-Tuple{Any}" href="#LearnConvection.Data.ReadNetCDF_OceananigansData-Tuple{Any}"><code>LearnConvection.Data.ReadNetCDF_OceananigansData</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>OceananigansData(filename)</p><p><strong>Description</strong></p><ul><li>Constructor for Oceananigans data type. Loads data from LES</li></ul><p><strong>Fields for the output are</strong></p><pre><code class="language-none"># initial conditions
Tâ°::ğ’®
Sâ°::ğ’®
Uâ°::ğ’®
Vâ°::ğ’®
# fields at each moment in time
T::ğ’¯
S::ğ’¯
U::ğ’¯
V::ğ’¯
# some second order statistics at each moment in time
wT::ğ’¯
wS::ğ’¯
uu::ğ’¯
vv::ğ’¯
ww::ğ’¯
# simulation constants
Ï::ğ’°
Î±::ğ’°
Î²::ğ’°
cáµ–::ğ’°
fâ°::ğ’°
g::ğ’°
# time and grid
t::ğ’®
z::ğ’®
#top boundary condition data, see string for type of boundary condition
top_T::ğ’°
top_S::ğ’°
top_U::ğ’°
top_V::ğ’°
#bottom boundary condition data, see string for type of boundary condtion
bottom_T::ğ’°
bottom_S::ğ’°
bottom_U::ğ’°
bottom_V::ğ’°
#info about the simulation
info::ğ’±</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/les/output_to_data.jl#L229-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.closure_free_convection_flexible-Tuple{Any,Any,LearnConvection.Data.OceananigansData}" href="#LearnConvection.Data.closure_free_convection_flexible-Tuple{Any,Any,LearnConvection.Data.OceananigansData}"><code>LearnConvection.Data.closure_free_convection_flexible</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>closure<em>free</em>convection_flexible(N, Î”t, les::OceananigansData; subsample = 1, grid = 1)</p><p><strong>Description</strong></p><ul><li>constructs forward map. Assumes initial conditions and boundary conditions are taken from les data. Adds two more parameters compared to previous one</li></ul><p><strong>Arguments</strong></p><ul><li><code>N</code>: number of gridpoints to output to</li><li><code>Î”t</code>: time step size in seconds</li><li><code>les</code>: les data of the OceananigansData type</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>subsample</code>: indices to subsample in time,</li><li><code>grid</code>: in case one wants to save the model grid</li><li><code>power</code>: a method of modifying the scaling law, default is 1</li></ul><p><strong>Output</strong></p><ul><li><p>The forward map. A function that takes parameters and outputs temperature profiles</p></li><li><p><code>ğ‘ª</code>: parameters in KPP, assumes that </p><p>ğ‘ª[1]: Surface Layer Fraction  </p><p>ğ‘ª[2]: Nonlocal Flux Amplitude </p><p>ğ‘ª[3]: Diffusivity Amplitude </p><p>ğ‘ª[4]: Shear Constant, w1 * w2 </p><p>ğ‘ª[5] = Shear Constant 2   ğ‘ª[6]: Shear Constant 3,</p></li><li><p>The extra parameters correspond to  C[5] * w1^(1-power) * w2^(1+power)</p></li><li><p>where w1 = max(0, h * Qb)^(1/3), w2 = sqrt(ğ‘ª[6] * h^2), are two velocity scales.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/kpp/run.jl#L118-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.closure_free_convection_kpp_full_evolution-Tuple{Any,Any,LearnConvection.Data.OceananigansData}" href="#LearnConvection.Data.closure_free_convection_kpp_full_evolution-Tuple{Any,Any,LearnConvection.Data.OceananigansData}"><code>LearnConvection.Data.closure_free_convection_kpp_full_evolution</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>closure<em>free</em>convection(N, Î”t, les::OceananigansData; subsample = 1, grid = 1)</p><p><strong>Description</strong></p><ul><li>constructs forward map. Assumes initial conditions and boundary conditions are taken from les data.</li></ul><p><strong>Arguments</strong></p><ul><li><code>N</code>: number of gridpoints to output to</li><li><code>Î”t</code>: time step size in seconds</li><li><code>les</code>: les data of the OceananigansData type</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>subsample</code>: indices to subsample in time,</li><li><code>grid</code>: in case one wants to save the model grid</li></ul><p><strong>Output</strong></p><ul><li><p>The forward map. A function that takes parameters and outputs temperature profiles</p></li><li><p><code>ğ‘ª</code>: parameters in KPP, assumes that </p><p>ğ‘ª[1]: Surface Layer Fraction  </p><p>ğ‘ª[2]: Nonlocal Flux Amplitude </p><p>ğ‘ª[3]: Diffusivity Amplitude </p><p>ğ‘ª[4]: Shear Constant </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/kpp/run.jl#L14-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.custom_avg-Tuple{Any,Any}" href="#LearnConvection.Data.custom_avg-Tuple{Any,Any}"><code>LearnConvection.Data.custom_avg</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>From sandreza/Learning/sandbox/oceananigans<em>converter.jl   https://github.com/sandreza/Learning/blob/master/sandbox/oceananigans</em>converter.jl</p><p>custom_avg(Î¦, n)</p><p><strong>Description</strong></p><ul><li>Average a field down to n.</li><li>Requires field to have evenly spaced points. Size of N leq length(Î¦).</li><li>Furthermore requires</li></ul><p><strong>Arguments</strong></p><ul><li><code>Î¦</code> :(vector) The field, an array</li><li><code>n</code> :(Int) number of grid points to average down to.</li></ul><p><strong>Return</strong></p><ul><li><code>Î¦2</code> :(vector) The field with values averaged, an array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/les/custom_avg.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.data-Tuple{Array{String,1},LearnConvection.Data.Problem}" href="#LearnConvection.Data.data-Tuple{Array{String,1},LearnConvection.Data.Problem}"><code>LearnConvection.Data.data</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>data(filename, D; N=4)</p><p><strong>Description</strong></p><p>Returns an instance of ProfileData containing training data from multiple simulations. *** Important:     ONLY v, x<em>train and y</em>train contain data from all filenames;     the remaining attributes are taken from the first filename in filenames</p><p><strong>Arguments</strong></p><ul><li><code>filenames</code>: (string)  Vector of filenames (.nc or .jld2) to collect data from.</li><li><code>problem</code>: (Problem). What mapping you wish to evaluate with the model. (Sequential(&quot;T&quot;), Sequential(&quot;wT&quot;), Residual(&quot;T&quot;), Residual(&quot;KPP&quot;), or Residual(&quot;TKE&quot;))</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>D</code>: (integer)        Number of gridpoints in the z direction to average the data to for training and prediction.</li><li><code>N</code>: (integer)        Interval between the timesteps to be reserved for training data (default 4).                       If N=4, the profile data for every 4 timesteps will be reserved for training (~25% training data);                       the rest will be used in the validation set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/Data.jl#L198-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.data-Tuple{String,LearnConvection.Data.Problem}" href="#LearnConvection.Data.data-Tuple{String,LearnConvection.Data.Problem}"><code>LearnConvection.Data.data</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>data(filename, problem; D=16, N=4)</p><p><strong>Description</strong></p><p>Returns a ProfileData object based on data from <code>filename</code></p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: (string)  Name of the NetCDF or JLD2 file containing the data from the Oceananigans simulation.</li><li><code>problem</code>: (Problem). What mapping you wish to evaluate with the model.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>D</code>: (integer)        Number of gridpoints in the z direction to average the data to for training and prediction.</li><li><code>N</code>: (integer)        Interval between the timesteps to be reserved for training data (default 4).                       If N=4, the profile data for every 4 timesteps will be reserved for training (~25% training data);                       the rest will be used in the validation set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/Data.jl#L119-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_T}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_T}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>get_predictors_targets(vavg::Array, problem::Sequential_T)</code></p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the predictors and target predictions from which to extract the training and verification data for &quot;T&quot; profiles.

model( predictors ) -&gt; targets
      model( T[i] ) -&gt; T[i+1]</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Sequential<em>T)     Sequential</em>T object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L74-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_wT}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Any,LearnConvection.Data.Sequential_wT}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>get_predictors_targets(vavg, problem::Sequential_wT)</code></p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the predictors and targets from which to extract the training and verification data for &quot;wT&quot; profiles.

 model( predictor ) -&gt; target
     model( wT[i] ) -&gt; wT[i+1]</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)                  Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Sequential<em>wT)       Sequential</em>wT object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L129-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Array,LearnConvection.Data.Sequential_dT}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,LearnConvection.Data.Sequential_dT}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>get_predictors_targets(vavg::Array, problem::Sequential_T)</code></p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the scaled predictor and target pairs from which to extract the training and verification data sets for &quot;T&quot; profiles.

model( predictor ) -&gt; target
     model( T[i] ) -&gt; (T[i+1]-T[i])/Î”t â‰ˆ âˆ‚t(T)</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)                Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Sequential<em>dT)     Sequential</em>T object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>get<em>predictors</em>targets(vavg::Array, problem::Residual_KPP)</p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.
Scales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.

model( predictors ) = targets
model( KPP(T[i])  ) = T[i] - KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Residual<em>KPP)    Residual</em>KPP object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/residual.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>get<em>predictors</em>targets(vavg::Array, problem::Residual_KPP)</p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.
Scales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.

model( predictors ) = targets
model( KPP(T[i])  ) = T[i] - KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Residual<em>KPP)    Residual</em>KPP object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L202-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}" href="#LearnConvection.Data.get_predictors_targets-Tuple{Array,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}"><code>LearnConvection.Data.get_predictors_targets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>get<em>predictors</em>targets(vavg::Array, problem::Slack_KPP)</p><p><strong>Description</strong></p><pre><code class="language-none">Returns x and y, the scaled predictors and target predictions from which to extract the training and verification data for temperature profiles.
Scales the predictors and targets using min-max scaling based on the initial temperature profile from the les simulation.

model( predictors ) = targets
model( KPP(T[i])  ) = T[i] - KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>vavg</code>: (Array)               Nt-length array of D-length vectors. Data from which to extract x and y, the predictors and corresponding predictions.</li><li><code>problem</code>: (Slack<em>KPP)    Slack</em>KPP object associated with the data (output of get_problem)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/slack.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_problem-NTuple{6,Any}" href="#LearnConvection.Data.get_problem-NTuple{6,Any}"><code>LearnConvection.Data.get_problem</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>get_problem(problem::Problem, data::OceananigansData, timeseries)</p><p><strong>Description</strong></p><pre><code class="language-none">Creates an instance of a Problem struct depending on the type of mapping.
Returns the problem and the correct data array from the OceananigansData objectssociated with the variable of interest.</code></pre><p><strong>Arguments</strong></p><ul><li>&#39;problem&#39;: (Problem).      what mapping you wish to evaluate with the model. (Sequential(&quot;T&quot;), Sequential(&quot;wT&quot;))</li><li>&#39;v&#39;: (Array).              Array of values</li><li>&#39;les&#39;: (OceananigansData). LES simulation output</li><li>&#39;NÂ²&#39;: (Number)             initial buoyancy stratification</li><li>&#39;D&#39;: (Number)              number of grid points in the vertical</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/problems.jl#L123-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.get_v-Tuple{Any,Any}" href="#LearnConvection.Data.get_v-Tuple{Any,Any}"><code>LearnConvection.Data.get_v</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>get_v(problem)</p><p><strong>Description</strong></p><pre><code class="language-none">Return data array from the OceananigansData object associated with the variable of interest.</code></pre><p><strong>Arguments</strong></p><ul><li>&#39;problem&#39;: (Problem).     what mapping you wish to evaluate with the model. (Sequential(&quot;T&quot;), Sequential(&quot;wT&quot;))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/problems.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_T}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_T}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>postprocess_prediction(predictor, prediction, problem::Sequential_T)</code></p><p><strong>Description</strong></p><p>Takes in a scaled predictor, T[i], the scaled GP prediction on the predictor, G(T[i]), and a Sequential_T object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by</p><pre><code class="language-none">       prediction = model( predictor )
 predicted T[i+1] = model( T[i] )</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)            T[i], the scaled predictor for a temperature profile</li><li><code>prediction</code>: (Array)           model(T[i), the scaled prediction for a temperature profile</li><li><code>problem</code>: (Sequential_T)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L103-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_dT}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_dT}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>postprocess_prediction(predictor, model_output, problem::Sequential_dT)</code></p><p><strong>Description</strong></p><p>Takes in a scaled predictor, T[i], the scaled model output on the predictor, model(T[i]), and a Sequential_T object. Returns the unscaled prediction (predicted temperature profile), T[i+1], computed from T[i] and model(T[i]) by</p><pre><code class="language-none">predicted T[i+1] = model(T[i])Î”t + T[i]</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)            T[i], the scaled predictor for a temperature profile</li><li><code>model_output</code>: (Array)         model(T[i]), the scaled model output for a temperature profile</li><li><code>problem</code>: (Sequential_dT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_wT}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,LearnConvection.Data.Sequential_wT}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><code>postprocess_prediction(predictor, prediction, problem::Sequential_wT)</code></p><p><strong>Description</strong></p><p>Takes in a scaled predictor, wT[i], the scaled model prediction on the predictor, model(wT[i]), and a Sequential_wT object. Returns the temperature profile, T[i+1], computed from model(T[i]) by</p><pre><code class="language-none">       prediction = model(predictor)
predicted wT[i+1] = model(wT[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)                wT[i], the predictor for a wT profile</li><li><code>prediction</code>: (Array)               predicted wT[i+1], the model prediction for a wT profile</li><li><code>problem</code>: (Sequential<em>wT)          Sequential</em>wT object associated with the data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L158-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Residual_KPP, LearnConvection.Data.Residual_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Description</strong></p><p>Takes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Residual_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by</p><pre><code class="language-none">       prediction = model(predictor) # residual
 predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)            T[i], the predictor for a temperature profile</li><li><code>prediction</code>: (Array)           model(T[i), the prediction for a temperature profile</li><li><code>problem</code>: (Residual_KPP)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/residual.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Sequential_KPP, LearnConvection.Data.Sequential_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Description</strong></p><p>Takes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Residual_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by</p><pre><code class="language-none">       prediction = model(predictor) # residual
 predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)            T[i], the predictor for a temperature profile</li><li><code>prediction</code>: (Array)           model(T[i), the prediction for a temperature profile</li><li><code>problem</code>: (Residual_KPP)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/sequential.jl#L231-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}" href="#LearnConvection.Data.postprocess_prediction-Tuple{Any,Any,Union{LearnConvection.Data.Slack_KPP, LearnConvection.Data.Slack_TKE}}"><code>LearnConvection.Data.postprocess_prediction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Description</strong></p><p>Takes in a predictor, T[i], the GP prediction on the predictor, G(T[i]), and a Slack_KPP object. Returns the predicted temperature profile, T[i+1], computed from T[i] and G(T[i]) by</p><pre><code class="language-none">       prediction = model(predictor) # residual
 predicted T[i+1] = model(KPP(T[i])) + KPP(T[i])</code></pre><p><strong>Arguments</strong></p><ul><li><code>predictor</code>: (Array)            T[i], the predictor for a temperature profile</li><li><code>prediction</code>: (Array)           model(T[i), the prediction for a temperature profile</li><li><code>problem</code>: (Slack_KPP)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adelinehillier/LearnConvection/blob/741934859512d68b952ab780c6d3549bbb73b447/src/data/slack.jl#L58-L70">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">Â« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 11 October 2020 10:19">Sunday 11 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
